<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="spring ioc 控制反转" />





  <link rel="alternate" href="/atom.xml" title="gamesdoa随记" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="spring几大核心组件中有一个就是IOC(Inversion of Control)，那么什么是IOC呢？它的原理是什么？它对我们的编程有什么影响?我们应该怎么样使用？下面我们就来分析分析">
<meta name="keywords" content="spring ioc 控制反转">
<meta property="og:type" content="article">
<meta property="og:title" content="spring IOC解析">
<meta property="og:url" content="http://gamesdoa.com/spring-ioc.html">
<meta property="og:site_name" content="gamesdoa随记">
<meta property="og:description" content="spring几大核心组件中有一个就是IOC(Inversion of Control)，那么什么是IOC呢？它的原理是什么？它对我们的编程有什么影响?我们应该怎么样使用？下面我们就来分析分析">
<meta property="og:image" content="https://github.com/gamesdoa/img0/raw/master/spring/BeanFactory.jpg">
<meta property="og:image" content="https://github.com/gamesdoa/img0/raw/master/spring/BeanDefinition.jpg">
<meta property="og:image" content="https://github.com/gamesdoa/img0/raw/master/spring/ApplicationContext.jpg">
<meta property="og:updated_time" content="2017-08-23T08:23:30.781Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring IOC解析">
<meta name="twitter:description" content="spring几大核心组件中有一个就是IOC(Inversion of Control)，那么什么是IOC呢？它的原理是什么？它对我们的编程有什么影响?我们应该怎么样使用？下面我们就来分析分析">
<meta name="twitter:image" content="https://github.com/gamesdoa/img0/raw/master/spring/BeanFactory.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'gamesdoa'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gamesdoa.com/spring-ioc.html"/>





  <title>spring IOC解析 | gamesdoa随记</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8d7f22e2a4a684f7bae123e14b5cdb35";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1262464870&web_id=1262464870" language="JavaScript"></script>
  </div>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gamesdoa随记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">边走边记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://gamesdoa.com/spring-ioc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="gamesdoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gamesdoa随记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">spring IOC解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/spring-ioc.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/spring-ioc.html" class="leancloud_visitors" data-flag-title="spring IOC解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          
              <div class="post-description">
                  spring几大核心组件中有一个就是IOC(Inversion of Control)，那么什么是IOC呢？它的原理是什么？它对我们的编程有什么影响?我们应该怎么样使用？下面我们就来分析分析
              </div>
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h1><p>IOC全称：Inversion of Control ，翻译成中文就是控制反转，主要的作用就是把我们原来在程序里面关联两个对象使用的new Object()方法，交给容器控制，也就是说将<strong>对象的创建和依赖关系交给容器</strong></p>
<p>那么对象之间的依赖怎么表示呢？</p>
<blockquote>
<p>可以用 xml ， properties 文件等语义化配置文件表示。</p>
</blockquote>
<p>描述对象关系的文件存放在哪里？</p>
<blockquote>
<p>可能是 classpath ， filesystem ，或者是 URL 网络资源， servletContext 等。</p>
</blockquote>
<h1 id="Spring-IOC体系结构"><a href="#Spring-IOC体系结构" class="headerlink" title="Spring IOC体系结构"></a>Spring IOC体系结构</h1><p>Spring IOC体系结构中有两个最重要的接口：</p>
<ul>
<li>BeanFactory：核心工厂接口，这个主要是创建Bean的</li>
<li>BeanDefinition ： bean对象以及其相互关系的定义接口</li>
</ul>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p><img src="https://github.com/gamesdoa/img0/raw/master/spring/BeanFactory.jpg" alt="BeanFactory架构图"><br>从这个架构图中可以看出BeanFactory的架构继承实现关系</p>
<p>BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范；</p>
<p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。</p>
<p>spring为何要定义这么多层次的接口？其实这个设计主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。</p>
<blockquote>
<p>ListableBeanFactory 接口表示这些 Bean 是可列表的;</p>
<p>HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean;</p>
<p>AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则</p>
</blockquote>
<pre><code>package org.springframework.beans.factory;

import org.springframework.beans.BeansException;

public interface BeanFactory {

    /**
     * 用于取消引用FactoryBean实例，并将其与FactoryBean创建的bean进行区分
     * 例如，如果获取名为myJndiObject的bean是FactoryBean，则获取＆myJndiObject将返回工厂，
     * 而不返回工厂返回的实例。
     */
    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;

    /**
     * 返回指定bean的一个可能是共享的或独立的实例。
     * 如果在此工厂实例中找不到该bean，将查找父工厂。
     * @param 要查找的bean名称
     * @返回一个Bean的实例
     * @throws NoSuchBeanDefinitionException如果没有bean定义指定名称
     * @throws BeansException如果无法获取该bean
     */
    Object getBean(String name) throws BeansException;

    /**
     * 返回指定bean的一个可能是共享的或独立的实例。
     * 如果在此工厂实例中找不到该bean，将查找父工厂。
     * @param 要查找的bean名称
     * @param requiredType键入bean必须匹配。可以是一个接口或超类，或匹配任意的null。
         例如，如果值是Object.class，这个方法将无论什么类都成功返回实例。
     * @返回一个Bean的实例
     * @throws NoSuchBeanDefinitionException如果没有这样的bean定义
     * @throws BeanNotOfRequiredTypeException如果bean不是必需的类型
     * @throws BeansException如果无法创建bean 
     */
    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;

    /**
     * 返回与给定对象类型唯一匹配的bean实例（如果有的话）。
     * @param requiredType键入bean必须匹配;可以是一个接口或超类。不允许为null。
     * 此方法进入ListableBeanFactory按类型查找区域，但也可以根据名称翻译成常规的副名称查找给定类型。
     * 对于多组bean的更广泛的检索操作，使用ListableBeanFactory或BeanFactoryUtils。
     * 返回匹配所需类型的单个bean的实例
     * @throws NoSuchBeanDefinitionException如果没有找到一个匹配的bean
     */
    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;

    /**
     *返回指定bean的一个可能是共享的或独立的实例。
     * 允许指定显式构造函数参数/工厂方法参数，覆盖bean定义中指定的默认参数（如果有）。
     * @param 要查找的bean名称
     * @param args使用参数，如果使用明确的参数创建一个原型静态工厂方法。在任何其他情况下使用非空args值无效。
     * @返回一个Bean的实例
     * @throws NoSuchBeanDefinitionException如果没有这样的bean定义
     * @throws BeanDefinitionStoreException如果已经给出了参数受影响的bean不是原型
     * @throws BeansException如果无法创建bean
     */
    Object getBean(String name, Object... args) throws BeansException;

    /**
     *这个bean工厂是否包含一个bean定义或外部注册的具有给定名称的单例实例？
     *如果给定的名称是别名，它将被翻译回相应的规范bean名称。
     *如果这个工厂是分层的，如果在这个工厂实例中找不到该bean，则会在其他工厂中查找，直到找到或者所有工厂查询完。
     *如果在相应的范围内找到匹配给定名称的bean定义或单例实例，该方法将返回true，无论找到的bean是具体还是抽象，懒加载或立即加载。
      因此，请注意，此方法的真实返回值并不一定表示#getBean将能够获取相同名称的实例。
     * @param 要查找的bean名称
     * @返回是否存在具有给定名称的bean
     */
    boolean containsBean(String name);

    /**
     * 这个bean是不是单例的？ 也就是说，#getBean是否会始终返回相同的实例？
     * 注意：此方法返回false并不能清楚的说明是单例。它也可能是非单例实例，只是对应的作用域不同。 使用#isPrototype操作来显式检查是否全局单例。
     * 将别名转换回相应的规范bean名称。 如果在此工厂实例中找不到该bean，将查询父工厂。
     * @param 要查找的bean名称
     * @返回这个bean是否对应于单例实例
     * @throws NoSuchBeanDefinitionException如果没有给定名称的bean
     */
    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;

    /**
     * bean是不是一个原型，#getBean是不是会一直返回独立的实例？
     * 注意：此方法返回false并不能清楚的说明是单例。它也可能是非单例实例，只是对应的作用域不同。 使用{@link #isSingleton}操作来显式检查共享的单例实例。
     * 将别名转换回相应的规范bean名称。 如果在此工厂实例中找不到该bean，将查询父工厂。
     * @param 要查找的bean名称
     * @返回这个bean是否会始终提供独立的实例
     * @throws NoSuchBeanDefinitionException如果没有给定名称的bean
     */
    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;

    /**
     *检查给定名称的bean是否与指定的类型匹配。 
     * 更具体地说，检查给定名称的{@link #getBean}调用是否返回可分配给指定目标类型的对象。
     * 将别名转换回相应的规范bean名称。 如果在此工厂实例中找不到该bean，将查询父工厂。
     * @param 要查找的bean名称
     * @param targetType匹配的类型
     * @return  true 如果bean类型匹配， false 如果不匹配或无法确定
     * @throws NoSuchBeanDefinitionException如果没有给定名称的bean
     */
    boolean isTypeMatch(String name, Class&lt;?&gt; targetType) throws NoSuchBeanDefinitionException;

    /**
     *确定具有给定名称的bean的类型。 更具体地说，确定{@link #getBean}将为给定名称返回的对象的类型。
     * 对于{@link FactoryBean}，返回FactoryBean创建的对象类型，如{@link FactoryBean＃getObjectType（））所示。
     * 将别名转换回相应的规范bean名称。 如果在此工厂实例中找不到该bean，将查询父工厂。
     * @param命名要查询的bean的名称 返回bean的类型，如果不可确定，则返回null
     * @throws NoSuchBeanDefinitionException如果没有给定名称的bean
     */
    Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;

    /**
     *返回给定bean名称的别名（如果有）。 当在{@link #getBean}调用中使用时，所有这些别名都指向同一个bean。
     * 如果给定的名称是别名，将返回相应的原始bean名称和其他别名（如果有的话），原始bean名称是数组中的第一个元素。
     * 如果在此工厂实例中找不到该bean，将查找父工厂。
     * @param 要查找的bean名称
     * @返回别名，如果没有，则返回一个空数组
     */
    String[] getAliases(String name);

}
</code></pre><p>从源码上看BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义又是怎样加载的。正如我们只关心工厂里能得到什么产品对象，至于工厂是怎么生产这些对象的，这个基本接口时不需要关心的。</p>
<p>而要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，spring提供了许多IOC容器的实现。</p>
<blockquote>
<p>比如XmlBeanFactory，ClasspathXmlApplicationContext等。</p>
<ul>
<li>XmlBeanFactory就是针对最基本的ioc容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述）。</li>
<li>ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了其他的附加服务。<blockquote>
<p>从ApplicationContext接口的实现，我们看出其特点：</p>
</blockquote>
</li>
</ul>
</blockquote>
<pre><code>org.springframework.context

import org.springframework.beans.factory.HierarchicalBeanFactory;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.core.env.EnvironmentCapable;
import org.springframework.core.io.support.ResourcePatternResolver;

public interface ApplicationContext extends EnvironmentCapable, 
    ListableBeanFactory, HierarchicalBeanFactory,
    MessageSource, ApplicationEventPublisher, ResourcePatternResolver {
    }
</code></pre><blockquote>
<blockquote>
<ol>
<li>支持信息源，可以实现国际化。（实现MessageSource接口）</li>
<li>支持应用事件。(实现ApplicationEventPublisher接口)</li>
<li>访问资源。(实现ResourcePatternResolver接口)</li>
</ol>
</blockquote>
</blockquote>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p><img src="https://github.com/gamesdoa/img0/raw/master/spring/BeanDefinition.jpg" alt="BeanDefinition设计架构"></p>
<ul>
<li>注 BeanDefinition是用来描述各种bean对象以及其相互的关系的定义继承了两个接口 <blockquote>
<p>AttributeAccessor:使其具有了处理属性的能力</p>
<p>BeanMetadataElement : 使其具有了获取bean配置定义的元素 </p>
</blockquote>
</li>
</ul>
<p>看一下源码：</p>
<pre><code>package org.springframework.beans.factory.config;

import org.springframework.beans.BeanMetadataElement;
import org.springframework.beans.MutablePropertyValues;
import org.springframework.core.AttributeAccessor;

public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {

    /**
     * 单例表示 : &quot;singleton&quot;.
     * 扩展bean工厂可能会支持更多的范围。
     */
    String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;

    /**
     * 标准原型范围的范围标识符：“原型”。
     * 扩展bean工厂可能会支持更多的范围。
     */
    String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;


    /**
     * 角色提示，表明一个  BeanDefinition 是应用程序的主要部分。
     * 通常对应于用户定义的bean。
     */
    int ROLE_APPLICATION = 0;


    /**
     * 返回此bean定义的父定义的名称（如果有）。
     */
    String getParentName();

    /**
     * 设置此bean定义的父定义的名称（如果有）。
     */
    void setParentName(String parentName);

    /**
     * 返回此bean定义的当前bean类名。
     * 请注意，这不一定是在运行时使用的实际类名，以便于子类定义从其父类覆盖/继承类名。 
     * 因此，不要认为这是在运行时确定的bean类型，而仅仅是在各个bean定义级别使用它来做解析的目的。
     */
    String getBeanClassName();

    /**
     * 覆盖此bean定义的bean类名称。
     * 可以在bean工厂之后处理修改类名称，通常用解析变量替换原始类名。
     */
    void setBeanClassName(String beanClassName);

    /**
     * 返回工厂bean名称，如果有的话。
     */
    String getFactoryBeanName();

    /**
     * 指定要使用的工厂bean（如果有）。
     */
    void setFactoryBeanName(String factoryBeanName);

    /**
     * 返回工厂方式，如果有的话
     */
    String getFactoryMethodName();

    /**
     * 指定工厂方法（如果有）。 该方法将使用构造函数参数进行调用，如果没有指定，则不使用参数。 
     * 该方法将在指定的工厂bean（如果有）或其他方式在本地bean类上作为静态方法调用。
    * @param factoryMethodName 静态工厂方法名称，如果正常的构造函数创建应该使用null
     */
    void setFactoryMethodName(String factoryMethodName);

    /**
     * 返回此bean的当前目标作用域的名称，如果不知道返回null
     */
    String getScope();

    /**
     * 覆盖当前的目标作用域
     * @see #SCOPE_SINGLETON
     * @see #SCOPE_PROTOTYPE
     */
    void setScope(String scope);

    /**
     * 返回这个bean是否应该被懒加载，即启动时不需要立即实例化。
     * 仅适用于单例
     */
    boolean isLazyInit();

    /**
     * 设置这个bean是否需要懒加载
     * 如果是false，那么bean将在启动时被bean factory实例化，bean factory会对单例立即初始化
     */
    void setLazyInit(boolean lazyInit);

    /**
     * 获取依赖的beanName
     */
    String[] getDependsOn();

    /**
     * 设置依赖的beanName
     * bean factory将保证这些bean首先被初始化.
     */
    void setDependsOn(String[] dependsOn);

    /**
     * 返回这个bean是否是自动关联到其他bean。
     */
    boolean isAutowireCandidate();

    /**
     * 设置这个bean是否自动关联到其他的bean.
     */
    void setAutowireCandidate(boolean autowireCandidate);

    /**
     * 返回该bean是否是主要的关联着。 如果这个值对于多个匹配bean中的一个bean是真实的，则它将作为一个主要关联者。
     */
    boolean isPrimary();

    /**
     * 设置这个bean是否是为主要的关联者。
     * 如果这个值对于多个匹配bean中的一个bean是真实的，则它将用作主要关联者
     */
    void setPrimary(boolean primary);


    /**
     * 返回此bean的构造函数的参数值。
     * 可以在bean factory 处理期间修改返回的实例。
     * @返回ConstructorArgumentValues对象（never  null）
     */
    ConstructorArgumentValues getConstructorArgumentValues();

    /**
     * 返回要应用于bean的新实例的属性值.
     * 可以在bean factory 处理期间修改返回的实例。
     * @return the MutablePropertyValues object (never &lt;code&gt;null&lt;/code&gt;)
     */
    MutablePropertyValues getPropertyValues();


    /**
     * 返回是否是一个单例，如果是一个单例，在所有调用上返回同一个实例。
     */
    boolean isSingleton();

    /**
     * 返回这是否为原型，如果是每个调用返回一个独立的实例。
     * @see #SCOPE_PROTOTYPE
     */
    boolean isPrototype();

    /**
     * 返回这个bean是否是“抽象的”，也就是，不要进行实例化。
     */
    boolean isAbstract();

    /**
     * 获取此BeanDefinition的角色提示。 角色提示为工具提供了特定BeanDefinition的重要性
     * @see #ROLE_APPLICATION
     * @see #ROLE_INFRASTRUCTURE
     * @see #ROLE_SUPPORT
     */
    int getRole();

    /**
     * 返回这个bean定义的可读的描述。
     */
    String getDescription();

    /**
     *返回此bean定义来源的资源的描述（用于出现错误情况下显示上下文）。
     */
    String getResourceDescription();

    /**
     * 返回原始BeanDefinition，不存在返回null。
     * 允许检索装饰的bean定义（如果有）。
     * 请注意，此方法返回当前发起者。通过发起者链迭代，以查找用户定义的原始BeanDefinition。
     */
    BeanDefinition getOriginatingBeanDefinition();

}
</code></pre><p>从源码来看这里和依赖关系相关的方法主要是 <strong>getDependsOn()</strong>和<strong>setDependsOn()</strong>，也是在初始化过程中把读取到的依赖关系通过set方法设置到BeanDefinition中保存的。</p>
<h1 id="spring-IOC-流程"><a href="#spring-IOC-流程" class="headerlink" title="spring IOC 流程"></a>spring IOC 流程</h1><p><strong>流程概述</strong></p>
<p>在使用spring IOC的情况下，需要什么信息才能创建bean呢？</p>
<ol>
<li>需要持有各种bean的定义</li>
<li>需要持有bean之间的依赖关系</li>
<li>需要一个工具完成上述需求的读取</li>
</ol>
<p>前面介绍BeanFactory的时候我们说到，BeanFactory的默认实现是DefaultListableBeanFactory，我们参看源码可以看到在DefaultListableBeanFactory中持有一个BeanDefinition的集合，该集合记录了从Resource定位、载入和注册的bean的定义和依赖关系。</p>
<pre><code>private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();
</code></pre><blockquote>
<p>总结的来说：</p>
<ul>
<li>需要一个file指向我们的xml：资源定位，指到XML的位置</li>
<li>需要一个Reader读取XML： DOM解析</li>
<li>需要将解析出来的数据设置到beanDefinitionMap中。</li>
</ul>
</blockquote>
<p><strong>ClasspathXmlApplicationContext解析</strong></p>
<h2 id="整体看继承实现关系"><a href="#整体看继承实现关系" class="headerlink" title="整体看继承实现关系"></a>整体看继承实现关系</h2><p>ClasspathXmlApplicationContext是ApplicationContext容器继承体系中的一个具体实现，该体系中还包含XmlWebApplicationContext和FileSystemXmlApplicationContext等，其继承体系如下图所示：<br><img src="https://github.com/gamesdoa/img0/raw/master/spring/ApplicationContext.jpg" alt="XmlWebApplicationContext设计架构图"></p>
<blockquote>
<ul>
<li>图中关注标红的对象ApplicationContext基本接口；</li>
<li>ClasspathXmlApplicationContext这个类是从classpath下加载配置文件(适合于相对路径方式加载)；</li>
<li>XmlWebApplicationContext专为web工程定制的方法，推荐Web项目中使用；</li>
<li>FileSystemXmlApplicationContext这个类是从文件绝对路径加载配置文件。</li>
</ul>
<p>注：ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。(在BeanFactory源码中获取bean的方法注释中有提到过)</p>
</blockquote>
<h2 id="ClasspathXmlApplicationContext的IOC容器流程"><a href="#ClasspathXmlApplicationContext的IOC容器流程" class="headerlink" title="ClasspathXmlApplicationContext的IOC容器流程"></a>ClasspathXmlApplicationContext的IOC容器流程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>//该方法参数中classpath: 前缀是不需要的，默认就是指项目的classpath路径下面；
//这也就是说用ClassPathXmlApplicationContext时默认的根目录是在WEB-INF/classes下面，而不是项目根目录。
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;/applicationcontext.xml&quot;);
</code></pre><h3 id="ClassPathXmlApplicationContext完整源码"><a href="#ClassPathXmlApplicationContext完整源码" class="headerlink" title="ClassPathXmlApplicationContext完整源码"></a>ClassPathXmlApplicationContext完整源码</h3><p>下面我们来看一下ClassPathXmlApplicationContext源码中都干了些什么事情？</p>
<pre><code>package org.springframework.context.support;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;

public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {

    private Resource[] configResources;

    /**
     * 用bean-style的配置创建一个新的ClassPathXmlApplicationContext.
     */
    public ClassPathXmlApplicationContext() {
    }

    /**
     * 用bean-style的配置创建一个新的ClassPathXmlApplicationContext.
     * @param parent 父上下文
     */
    public ClassPathXmlApplicationContext(ApplicationContext parent) {
        super(parent);
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件加载definitions并自动刷新上下文。
     * @param configLocation 资源位置
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
        this(new String[] {configLocation}, true, null);
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件加载definitions并自动刷新上下文。
     * @param configLocations 资源位置数组
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String... configLocations) throws BeansException {
        this(configLocations, true, null);
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件加载definitions并自动刷新上下文。
     * @param configLocations 资源位置数组
     * @param parent 父上下文
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String[] configLocations, ApplicationContext parent) throws BeansException {
        this(configLocations, true, parent);
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件中加载定义。
     * @param configLocations 资源位置数组
     * @param refresh 是否自动刷新上下文，加载所有bean定义并创建所有单例。或者，在进一步配置上下文之后手动调用刷新。
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh) throws BeansException {
        this(configLocations, refresh, null);
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件中加载定义。
     * @param configLocations 资源位置数组
     * @param refresh 是否自动刷新上下文，加载所有bean定义并创建所有单例。或者，在进一步配置上下文之后手动调用刷新。
     * @param parent 父上下文
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException {
        super(parent);
        setConfigLocations(configLocations);
        if (refresh) {
            refresh();
        }
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件加载definitions并自动刷新上下文。
     * 这是一个加载资源路径相对于给定类的方法。
     * 为了充分的灵活性，请考虑使用GenericApplicationContext与XmlBeanDefinitionReader和ClassPathResource参数。
     * @param path 类路径内的相对（或绝对）路径
     * @param clazz 加载资源的类（给定基础的路径）
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String path, Class clazz) throws BeansException {
        this(new String[] {path}, clazz);
    }

    /**
     * 创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件加载definitions并自动刷新上下文。
     * @param paths 类路径内的相对（或绝对）路径数组
     * @param clazz 加载资源的类（给定基础的路径）
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String[] paths, Class clazz) throws BeansException {
        this(paths, clazz, null);
    }

    /**
     * 根据给定的路径创建一个新的ClassPathXmlApplicationContext，并从给定的XML文件加载definitions并自动刷新上下文。
     * @param paths 类路径内的相对（或绝对）路径数组
     * @param clazz 加载资源的类（给定基础的路径）
     * @param parent 父上下文
     * @throws BeansException 如果创建失败抛出异常
     */
    public ClassPathXmlApplicationContext(String[] paths, Class clazz, ApplicationContext parent)
            throws BeansException {
        super(parent);
        Assert.notNull(paths, &quot;Path array must not be null&quot;);
        Assert.notNull(clazz, &quot;Class argument must not be null&quot;);
        this.configResources = new Resource[paths.length];
        for (int i = 0; i &lt; paths.length; i++) {
            this.configResources[i] = new ClassPathResource(paths[i], clazz);
        }
        refresh();
    }

    @Override
    protected Resource[] getConfigResources() {
        return this.configResources;
    }
}
</code></pre><h3 id="解析初始化"><a href="#解析初始化" class="headerlink" title="解析初始化"></a>解析初始化</h3><p>回到我们刚刚的初始化部分，将会调用构造函数：</p>
<pre><code>public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
    this(new String[] {configLocation}, true, null);
}
</code></pre><p>该构造函数实际上调用</p>
<pre><code>public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException {
    super(parent);
    setConfigLocations(configLocations);
    if (refresh) {
        refresh();
    }
}
</code></pre><blockquote>
<p>通过分析ClassPathXmlApplicationContext的源代码和我们单独提出来的初始化方法可以知道，在创建ClassPathXmlApplicationContext容器时，构造方法做以下三项工作：</p>
<ul>
<li>用父类容器的构造方法(super(parent)方法)为容器设置好Bean资源加载器。主要是设置了下面这三个属性<blockquote>
<p>this.parent = parent;//父上下文</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>this.resourcePatternResolver = getResourcePatternResolver();//资源解析器</p>
<p>this.environment = this.createEnvironment();//环境</p>
</blockquote>
<ul>
<li>调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置Bean定义的资源文件的路径。</li>
<li>是否立刻刷新上下文，如果不立刻刷新的话可以在进一步配置上下文之后手动调用刷新。</li>
</ul>
</blockquote>
<h4 id="设置Bean资源加载器"><a href="#设置Bean资源加载器" class="headerlink" title="设置Bean资源加载器"></a>设置Bean资源加载器</h4><p>接下来看一下ClassPathXmlApplicationContext的父类AbstractApplicationContext在初始化IoC容器中会做哪些事情，也就是设置Bean资源加载器这里，我们可以从架构图上看到AbstractApplicationContext并不是ClassPathXmlApplicationContext的直接父类，而是四层父类，中间的父类在初始化的时候只是调用了super(parent)方法，具体的处理还是在AbstractApplicationContext中，这部分的主要源码如下：</p>
<pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean {  
    //静态初始化块，在整个容器创建过程中只执行一次  
    static {  
        //为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容器关闭事件(ContextClosedEvent)类  
        ContextClosedEvent.class.getName();  
    }
    ……
    //ClassPathXmlApplicationContextt调用父类构造方法调用的就是该方法  
    public AbstractApplicationContext(ApplicationContext parent) {  
        this.parent = parent;
        this.resourcePatternResolver = getResourcePatternResolver();
        this.environment = this.createEnvironment();
    }  
    //获取一个Spring Source的加载器用于读入Spring Bean定义资源文件  
    protected ResourcePatternResolver getResourcePatternResolver() {
        //AbstractApplicationContext继承DefaultResourceLoader，也是一个Spring资源加载器，其getResource(String location)方法用于载入资源 
        return new PathMatchingResourcePatternResolver(this);
    } 
    ……  
}
</code></pre><p>AbstractApplicationContext构造方法中调用的getResourcePatternResolver()方法中创建了一个新的PathMatchingResourcePatternResolver创建Spring资源加载器：</p>
<pre><code>public class PathMatchingResourcePatternResolver implements ResourcePatternResolver {
    ……
    public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {
        Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);
        this.resourceLoader = resourceLoader;
    }
    ……
}
</code></pre><h4 id="定位bean定义的资源文件"><a href="#定位bean定义的资源文件" class="headerlink" title="定位bean定义的资源文件"></a>定位bean定义的资源文件</h4><p>在设置完容器的资源加载器之后，接下来ClassPathXmlApplicationContext执行setConfigLocations方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对指定Bean定义的资源文件的定位，该方法的源码如下：</p>
<pre><code>public abstract class AbstractRefreshableConfigApplicationContext extends AbstractRefreshableApplicationContext 
    implements BeanNameAware, InitializingBean {
    ……

    /**
     * 在init-param style中设置此应用程序上下文的配置位置，即用逗号，分号或空格分隔的不同位置。
     * 如果未设置，则实施可能会使用默认值。
     */
    public void setConfigLocation(String location) {
        setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));
    }

    /**
     * 设置此应用程序上下文的配置位置.
     * 如果未设置，则使用时可能会使用默认值。
     */
    public void setConfigLocations(String[] locations) {
        if (locations != null) {
            Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);
            this.configLocations = new String[locations.length];
            for (int i = 0; i &lt; locations.length; i++) {
                //resolvePath为同一个类中将字符串解析为路径的方法
                this.configLocations[i] = resolvePath(locations[i]).trim();
            }
        }
        else {
            this.configLocations = null;
        }
    }
    ……
}
</code></pre><blockquote>
<p>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean定义文件，也可以使用字符串数组，即下面两种方式都是可以的：</p>
<ul>
<li>ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”);  多个资源文件路径之间可以是用”,;/t/n”等分隔。</li>
<li>ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……});</li>
</ul>
</blockquote>
<p>到这里，Spring IoC容器在初始化时将配置的Bean定义文件定位为Spring封装的Resource的工作就完成了。</p>
<h4 id="refresh方法"><a href="#refresh方法" class="headerlink" title="refresh方法"></a>refresh方法</h4><p>我们说过初始化过程包含Resource定位、载入和Bean注册三个步骤，各个我们学习了Resource定位问题，下面我们来看一下载入这一步。<br>我们看到在初始化的第三步判断是否立刻刷新上下文，这里就是载入的入口部分了，也就是refresh()方法，refresh()是一个模板方法。</p>
<h5 id="refresh源码"><a href="#refresh源码" class="headerlink" title="refresh源码"></a>refresh源码</h5><p>ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器对Bean定义的载入过程：</p>
<pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader
    implements ConfigurableApplicationContext, DisposableBean {
    ……
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // 调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  
            prepareRefresh();

            // 告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从子类的refreshBeanFactory()方法启动  
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // 为BeanFactory配置容器特性，例如类加载器、事件处理器等 
            prepareBeanFactory(beanFactory);

            try {
                // 为容器的某些子类指定特殊的BeanPost事件处理器  
                postProcessBeanFactory(beanFactory);

                //调用所有该上下文中注册的BeanFactoryPostProcessor的Bean 
                invokeBeanFactoryPostProcessors(beanFactory);

                // 为BeanFactory注册BeanPost事件处理器. 
                // BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件  
                registerBeanPostProcessors(beanFactory);

                // 初始化该上下文的信息源，和国际化相关.
                initMessageSource();

                // 初始化该上下文容器事件传播器.
                initApplicationEventMulticaster();

                // 在特定的上下文子类中初始化其他特殊的bean.
                onRefresh();

                // 检查监听器bean并注册它们.
                registerListeners();

                // 实例化所有剩下的（非lazy-init）单例.
                finishBeanFactoryInitialization(beanFactory);

                // 最后一步：发布相应的事件.
                finishRefresh();
            } catch (BeansException ex) {
                //销毁已经创建的单例，以避免资源悬空.
                destroyBeans();
                // 重置 &apos;active&apos; 标识.
                cancelRefresh(ex);
                // 抛出异常给调用者.
                throw ex;
            }
        }
    }
    ……
    /**
     * 告诉子类启动refreshBeanFactory()方法，
     * @return 刷新的BeanFactory实例
     */
    protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
        //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
        refreshBeanFactory();
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
        }
        return beanFactory;
    }
    ……
    protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;
    ……
}
</code></pre><p>Spring IoC容器载入Bean定义的资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。</p>
<p>refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入。</p>
<h5 id="refreshBeanFactory源码"><a href="#refreshBeanFactory源码" class="headerlink" title="refreshBeanFactory源码"></a>refreshBeanFactory源码</h5><ul>
<li>AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法，</li>
</ul>
<p>方法的源码如下：</p>
<pre><code>public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
    ……
    /**
     * 此实现将对该上下文的底层BeanFactory进行实际刷新，关闭以前的BeanFactory（如果有），
     * 并为上下文生命周期的下一阶段初始化一个新的BeanFactory。
     */
    @Override
    protected final void refreshBeanFactory() throws BeansException {
        if (hasBeanFactory()) {
            //如果已经有容器，销毁容器中的bean，关闭容器 
            destroyBeans();
            closeBeanFactory();
        }
        try {
            //创建新的IoC容器也就是BeanFactory
            DefaultListableBeanFactory beanFactory = createBeanFactory();
            beanFactory.setSerializationId(getId());
            //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等 
            customizeBeanFactory(beanFactory);
            //调用载入Bean定义的方法，这里又使用了委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器
            loadBeanDefinitions(beanFactory);
            synchronized (this.beanFactoryMonitor) {
                this.beanFactory = beanFactory;
            }
        }
        catch (IOException ex) {
            throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
        }
    }
    ……
    /**
     * 通常通过委托一个或多个bean definition readers将beande finition加载到给定的bean工厂中。
     * @param beanFactory 用于加载bean definitions的beanFactory
     * @throws BeansException 如果解析bean definitions失败
     * @throws IOException if 如果加载bean definitions文件失败
     */
    protected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)
            throws BeansException, IOException;
    ……
}
</code></pre><blockquote>
<p>在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关闭beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义。</p>
<h5 id="loadBeanDefinitions源码"><a href="#loadBeanDefinitions源码" class="headerlink" title="loadBeanDefinitions源码"></a>loadBeanDefinitions源码</h5><ul>
<li>AbstractRefreshableApplicationContext中只定义了抽象的loadBeanDefinitions()方法，容器真正调用的是其子类AbstractXmlApplicationContext对该方法的实现.</li>
</ul>
</blockquote>
<p>主要源码如下：</p>
<pre><code>public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {
    ……
    /**
     * 通过 XmlBeanDefinitionReader 加载 bean definitions.
     */
    @Override
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        // 根据给定的BeanFactory创建一个新的XmlBeanDefinitionReader.
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

        // 根据上下文资源环境配置bean definition reader的环境.
        beanDefinitionReader.setEnvironment(this.getEnvironment());

        //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的  
        //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器 
        beanDefinitionReader.setResourceLoader(this);

        //为Bean读取器设置SAX xml解析器 
        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

        // 允许子类提供reader的自定义初始化，然后继续实现加载bean definitions。
        initBeanDefinitionReader(beanDefinitionReader);

        //Bean读取器真正实现加载的方法
        loadBeanDefinitions(beanDefinitionReader);
    }
    ……
    /**
     * 使用给定的XmlBeanDefinitionReader加载bean definitions。
     * bean工厂的生命周期由#refreshBeanFactory方法处理; 因此这个方法只是加载和/或注册bean定义。
     * @param reader the XmlBeanDefinitionReader to use
     * @throws BeansException in case of bean registration errors
     * @throws IOException if the required XML document isn&apos;t found
     */
    protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
        //获取Bean定义资源的定位
        Resource[] configResources = getConfigResources();
        if (configResources != null) {
            //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源  
            reader.loadBeanDefinitions(configResources);
        }

        //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源
        String[] configLocations = getConfigLocations();
        if (configLocations != null) {
            //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源 
            reader.loadBeanDefinitions(configLocations);
        }
    }
    ……
    /**
     * 返回一个资源对象数组，引用这个上下文应该构建的XML bean定义文件。
     * 默认实现返回null。 子类可以覆盖此提供预先构建的资源对象而不是位置字符串。
     * 这里使用了委托模式，调用子类的获取Bean定义资源定位的方法，该方法在ClassPathXmlApplicationContext中进行实现，
     * FileSystemXmlApplicationContext中并没有实现
     * @return an array of Resource objects, or &lt;code&gt;null&lt;/code&gt; if none
     * @see #getConfigLocations()
     */
    protected Resource[] getConfigResources() {
        return null;
    }
    ……
}
</code></pre><blockquote>
<p>Xml Bean读取器(XmlBeanDefinitionReader)调用其父类AbstractBeanDefinitionReader的reader.loadBeanDefinitions方法读取Bean定义资源。</p>
</blockquote>
<p>ClassPathXmlApplicationContext中重写了getConfigResources()方法，返回configResources的属性的值。</p>
<pre><code>public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {
    ……
    @Override
    protected Resource[] getConfigResources() {
        return this.configResources;
    }
    ……
}
</code></pre><p>然后根据情况判断是否执行reader.loadBeanDefinitions(configResources)分支，之后再获取getConfigLocations(),判断是否执行reader.loadBeanDefinitions(configLocations)分支。</p>
<h5 id="读取Bean定义资源"><a href="#读取Bean定义资源" class="headerlink" title="读取Bean定义资源"></a>读取Bean定义资源</h5><p>读取Bean定义资源的实际工作是在其抽象父类AbstractBeanDefinitionReader中定义的，主要源码：</p>
<pre><code>public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader {
    ……

    //重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法 
    public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
        return loadBeanDefinitions(location, null);
    }

    /**
     * 从指定的资源位置加载bean定义。
     * 该位置也可以是一个location pattern，前提是该bean定义阅读器的ResourceLoader是ResourcePatternResolver。
     * @param location 要加载这个bean定义阅读器的ResourceLoader（或ResourcePatternResolver）
     * @param actualResources 要在加载过程中解析的实际资源对象填充的集合。可能是null来表示调用者对这些资源对象不感兴趣。
     * @return the number of bean definitions found
     * @throws BeanDefinitionStoreException in case of loading or parsing errors
     */
    public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {
        //获取在IoC容器初始化过程中设置的资源加载器  
        ResourceLoader resourceLoader = getResourceLoader();
        if (resourceLoader == null) {
            throw new BeanDefinitionStoreException(
                    &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);
        }

        if (resourceLoader instanceof ResourcePatternResolver) {
            // 可以用资源模式匹配.
            try {
                //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源加载多个指定位置的Bean定义资源文件  
                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
                //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 
                int loadCount = loadBeanDefinitions(resources);
                if (actualResources != null) {
                    for (Resource resource : resources) {
                        actualResources.add(resource);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);
                }
                return loadCount;
            }
            catch (IOException ex) {
                throw new BeanDefinitionStoreException(
                        &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);
            }
        }
        else {
            //只能通过绝对URL加载单个资源。
            Resource resource = resourceLoader.getResource(location);
            //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能
            int loadCount = loadBeanDefinitions(resource);
            if (actualResources != null) {
                actualResources.add(resource);
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);
            }
            return loadCount;
        }
    }

    //重载方法，调用loadBeanDefinitions(String); 
    public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
        Assert.notNull(locations, &quot;Location array must not be null&quot;);
        int counter = 0;
        for (String location : locations) {
            counter += loadBeanDefinitions(location);
        }
        return counter;
    }
    ……
}
</code></pre><blockquote>
<p>loadBeanDefinitions(Resource…resources)方法和上面分析的3个方法类似，同样也是调用XmlBeanDefinitionReader的loadBeanDefinitions方法。从对AbstractBeanDefinitionReader的loadBeanDefinitions方法源码分析可以看出该方法做了以下两件事：</p>
<ul>
<li>调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。</li>
<li>真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions方法。</li>
</ul>
<p>通过ResourceLoader resourceLoader = getResourceLoader(); 和</p>
<p>Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</p>
<p>可以知道此时调用的是DefaultResourceLoader中的getSource()方法定位Resource</p>
</blockquote>
<h5 id="获取要读入的资源"><a href="#获取要读入的资源" class="headerlink" title="获取要读入的资源"></a>获取要读入的资源</h5><p>XmlBeanDefinitionReader通过调用其父类DefaultResourceLoader的getResource方法获取要加载的资源，其源码如下</p>
<pre><code>public class DefaultResourceLoader implements ResourceLoader {
    ……
    public Resource getResource(String location) {
        Assert.notNull(location, &quot;Location must not be null&quot;);
        //是不是classpath:，也就是相对路径
        if (location.startsWith(CLASSPATH_URL_PREFIX)) {
            return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
        }
        else {
            try {
                // 尝试将该位置解析为URL...
                URL url = new URL(location);
                return new UrlResource(url);
            }
            catch (MalformedURLException ex) {
                // 没有URL - &gt;解析为资源路径。
                return getResourceByPath(location);
            }
        }
    }
    ……
}
</code></pre><p>我们解析的 ClassPathXmlApplicationContext 符合location.startsWith(CLASSPATH_URL_PREFIX) 所以新建一个ClassPathResource返回，如果是FileSystemXmlApplicationContext的话，因为是绝对路径是应该是调用FileSystemXmlApplicationContext的getResourceByPath()方法返回Resource。</p>
<h5 id="加载Bean定义资源"><a href="#加载Bean定义资源" class="headerlink" title="加载Bean定义资源"></a>加载Bean定义资源</h5><p>Bean定义的Resource得到了，继续回到XmlBeanDefinitionReader的loadBeanDefinitions(Resource …)方法看到代表bean文件的资源定义以后的载入过程。</p>
<pre><code>public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
    /**
     * 从指定的XML文件加载bean定义。
     * @param resource the resource descriptor for the XML file
     * @return the number of bean definitions found
     * @throws BeanDefinitionStoreException in case of loading or parsing errors
     */
    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
        //将读入的XML资源进行特殊编码处理 
        return loadBeanDefinitions(new EncodedResource(resource));
    }

    /**
     * 从指定的XML文件加载bean定义。
     * @param encodedResource  XML文件的资源描述符，允许指定用于解析文件的编码
     * @return the number of bean definitions found
     * @throws BeanDefinitionStoreException in case of loading or parsing errors
     */
    public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
        if (logger.isInfoEnabled()) {
            logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
        }

        Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
        if (currentResources == null) {
            currentResources = new HashSet&lt;EncodedResource&gt;(4);
            this.resourcesCurrentlyBeingLoaded.set(currentResources);
        }
        if (!currentResources.add(encodedResource)) {
            throw new BeanDefinitionStoreException(
                    &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
        }
        try {
            //将资源文件转为InputStream的IO流 
            InputStream inputStream = encodedResource.getResource().getInputStream();
            try {
                //从InputStream中得到XML的解析源 
                InputSource inputSource = new InputSource(inputStream);
                if (encodedResource.getEncoding() != null) {
                    inputSource.setEncoding(encodedResource.getEncoding());
                }
                //这里是具体的读取过程  
                return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
            }
            finally {
                //关闭从Resource中得到的IO流   
                inputStream.close();
            }
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(
                    &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
        }
        finally {
            currentResources.remove(encodedResource);
            if (currentResources.isEmpty()) {
                this.resourcesCurrentlyBeingLoaded.remove();
            }
        }
    }
    /**
     * //从特定XML文件中实际载入Bean定义资源的方法 
     * @param inputSource the SAX InputSource to read from
     * @param resource the resource descriptor for the XML file
     * @return the number of bean definitions found
     * @throws BeanDefinitionStoreException in case of loading or parsing errors
     */
    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {
        try {
            int validationMode = getValidationModeForResource(resource);
            //将XML文件转换为DOM对象，解析过程由documentLoader实现  
            Document doc = this.documentLoader.loadDocument(
                    inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());
            //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则
            return registerBeanDefinitions(doc, resource);
        }
        ……
    }
}
</code></pre><blockquote>
<p>通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现</p>
</blockquote>
<h5 id="换为Document对象"><a href="#换为Document对象" class="headerlink" title="换为Document对象"></a>换为Document对象</h5><pre><code>public class DefaultDocumentLoader implements DocumentLoader {
    //使用标准的JAXP将载入的Bean定义资源转换成document对象
    public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {
        //创建文件解析器工厂 
        DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
        }
        //创建文档解析器
        DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
        //解析Spring的Bean定义资源
        return builder.parse(inputSource);
    }

    protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
            throws ParserConfigurationException {
        //创建文档解析工厂 
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(namespaceAware);
        //设置解析XML的校验
        if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
            factory.setValidating(true);
            if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
                factory.setNamespaceAware(true);
                try {
                    factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
                }
                catch (IllegalArgumentException ex) {
                    ParserConfigurationException pcex = new ParserConfigurationException(
                            &quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +
                            &quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; +
                            &quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);
                    pcex.initCause(ex);
                    throw pcex;
                }
            }
        }
        return factory;
    }
}
</code></pre><blockquote>
<p>该解析过程调用JavaEE标准的JAXP标准进行处理。</p>
</blockquote>
<p>至此Spring IoC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。</p>
<h5 id="解析Bean定义资源"><a href="#解析Bean定义资源" class="headerlink" title="解析Bean定义资源"></a>解析Bean定义资源</h5><p>XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML文件中实际载入Bean定义资源的方法，该方法在载入Bean定义资源之后将其转换为Document对象，接下来调用registerBeanDefinitions启动Spring IoC容器对Bean定义的解析过程，registerBeanDefinitions方法源码如下：</p>
<pre><code>public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
    //按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构
    public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
        //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析 
        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
        documentReader.setEnvironment(this.getEnvironment());
        //获得容器中注册的Bean数量
        int countBefore = getRegistry().getBeanDefinitionCount();

        //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，
        //具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成  
        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
        //统计解析的Bean数量
        return getRegistry().getBeanDefinitionCount() - countBefore;
    }

    //创建BeanDefinitionDocumentReader对象，解析Document对象
    protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
        return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));
    }
}
</code></pre><blockquote>
<p>Bean定义资源的载入解析分为以下两个过程：</p>
<ul>
<li>通过调用XML解析器将Bean定义资源文件转换得到Document对象，但是这些Document对象并没有按照Spring的Bean规则进行解析。这一步是载入的过程</li>
<li>在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析。</li>
</ul>
</blockquote>
<h5 id="对Document解析"><a href="#对Document解析" class="headerlink" title="对Document解析"></a>对Document解析</h5><p>BeanDefinitionDocumentReader接口通过registerBeanDefinitions方法调用其实现类DefaultBeanDefinitionDocumentReader对Document对象进行解析，解析的代码如下：</p>
<pre><code>public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
        this.readerContext = readerContext;

        logger.debug(&quot;Loading bean definitions&quot;);
        Element root = doc.getDocumentElement();

        doRegisterBeanDefinitions(root);
    }

    /**
     * 在给定的根{&lt;beans /&gt;元素中注册每个bean定义。
     */
    protected void doRegisterBeanDefinitions(Element root) {
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            Assert.state(this.environment != null, &quot;environment property must not be null&quot;);
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!this.environment.acceptsProfiles(specifiedProfiles)) {
                return;
            }
        }

        // 任何嵌套的&lt;beans&gt;元素将导致此方法中的递归。 
        // 为了正确地传播和保存&lt;beans&gt; default- *属性，请跟踪当前（父）委托，它可能为null。
        // 创建一个引用父（parent）的新的（子）代理，以便进行回退，然后最终将this.delegate重置为原始（父）引用。 
        // 这种行为模拟一堆代理，而不需要一个代理。
        BeanDefinitionParserDelegate parent = this.delegate;
        this.delegate = createHelper(readerContext, root, parent);

        preProcessXml(root);
        parseBeanDefinitions(root, this.delegate);
        postProcessXml(root);

        this.delegate = parent;
    }
    protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root, BeanDefinitionParserDelegate parentDelegate) {
        BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext, environment);
        delegate.initDefaults(root, parentDelegate);
        return delegate;
    }

    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
        if (delegate.isDefaultNamespace(root)) {
            NodeList nl = root.getChildNodes();
            for (int i = 0; i &lt; nl.getLength(); i++) {
                Node node = nl.item(i);
                if (node instanceof Element) {
                    Element ele = (Element) node;
                    if (delegate.isDefaultNamespace(ele)) {
                        parseDefaultElement(ele, delegate);
                    }
                    else {
                        delegate.parseCustomElement(ele);
                    }
                }
            }
        }
        else {
            delegate.parseCustomElement(root);
        }
    }

    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
            importBeanDefinitionResource(ele);
        } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
            processAliasRegistration(ele);
        } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
            processBeanDefinition(ele, delegate);
        } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
            // 递归
            doRegisterBeanDefinitions(ele);
        }
    }

    protected void importBeanDefinitionResource(Element ele) {
        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
        if (!StringUtils.hasText(location)) {
            getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);
            return;
        }

        // 解决系统属性：例如“${user.dir}”
        location = environment.resolveRequiredPlaceholders(location);

        Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4);

        // 发现位置是绝对的还是相对的URI
        boolean absoluteLocation = false;
        try {
            absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
        } catch (URISyntaxException ex) {
            // 不能转换为URI，考虑到位置相对，除非是众所周知的Spring前缀“classpath *：”
        }

        // 绝对还是相对？
        if (absoluteLocation) {
            try {
                int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);
                }
            } catch (BeanDefinitionStoreException ex) {
                getReaderContext().error(
                        &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);
            }
        }
        else {
            // 没有URL - &gt;考虑相对于当前文件的资源位置。
            try {
                int importCount;
                Resource relativeResource = getReaderContext().getResource().createRelative(location);
                if (relativeResource.exists()) {
                    importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
                    actualResources.add(relativeResource);
                } else {
                    String baseLocation = getReaderContext().getResource().getURL().toString();
                    importCount = getReaderContext().getReader().loadBeanDefinitions(
                            StringUtils.applyRelativePath(baseLocation, location), actualResources);
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);
                }
            } catch (IOException ex) {
                getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);
            } catch (BeanDefinitionStoreException ex) {
                getReaderContext().error(&quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);
            }
        }
        Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);
        getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
    }

    /**
     * 处理给定的别名元素，使用注册表注册别名。
     */
    protected void processAliasRegistration(Element ele) {
        String name = ele.getAttribute(NAME_ATTRIBUTE);
        String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
        boolean valid = true;
        if (!StringUtils.hasText(name)) {
            getReaderContext().error(&quot;Name must not be empty&quot;, ele);
            valid = false;
        }
        if (!StringUtils.hasText(alias)) {
            getReaderContext().error(&quot;Alias must not be empty&quot;, ele);
            valid = false;
        }
        if (valid) {
            try {
                getReaderContext().getRegistry().registerAlias(name, alias);
            }
            catch (Exception ex) {
                getReaderContext().error(&quot;Failed to register alias &apos;&quot; + alias +
                        &quot;&apos; for bean with name &apos;&quot; + name + &quot;&apos;&quot;, ele, ex);
            }
            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
        }
    }

    /**
     * 处理给定的bean元素，解析bean定义并将其注册到注册表。
     */
    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
        if (bdHolder != null) {
            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
            try {
                // 注册最终解析的实例.
                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
            }
            catch (BeanDefinitionStoreException ex) {
                getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +
                        bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);
            }
            // 发送注册事件.
            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
        }
    }

}
</code></pre><blockquote>
<p>通过上述Spring IoC容器对载入的Bean定义Document解析可以看出，我们使用Spring时，在Spring配置文件中可以使用<import>元素来导入IoC容器所需要的其他资源，Spring IoC容器在解析时会首先将指定导入的资源加载进容器中。使用<ailas>别名时，Spring IoC容器首先将别名元素所定义的别名注册到容器中。</ailas></import></p>
<p>对于既不是<import>元素，又不是<alias>元素的元素，即Spring配置文件中普通的<bean>元素的解析由BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法来实现。</bean></alias></import></p>
</blockquote>
<h5 id="BeanDefinitionParserDelegate"><a href="#BeanDefinitionParserDelegate" class="headerlink" title="BeanDefinitionParserDelegate"></a>BeanDefinitionParserDelegate</h5><p>该类主要作用是用于解析XML定义的bean定义为BeanDefinition对象。</p>
<p>解析Bean定义资源文件中的<bean>元素的方法：</bean></p>
<pre><code>//解析&lt;Bean&gt;元素的入口  
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {}
//解析Bean定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的id，name 和别名属性  
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { }
//详细对&lt;Bean&gt;元素中配置的Bean定义其他属性进行解析，由于上面的方法中已经对
//Bean的id、name和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据  
public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) { }
</code></pre><p>解析<property>元素的方法：</property></p>
<pre><code>//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素  
public void parsePropertyElements(Element beanEle, BeanDefinition bd) {}
//解析&lt;property&gt;元素  
public void parsePropertyElement(Element ele, BeanDefinition bd) {}
//解析获取property值  
public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) { } 
</code></pre><p>解析<property>元素的子元素的方法：</property></p>
<pre><code>//解析&lt;property&gt;元素中ref,value或者集合等子元素  
public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) {}
</code></pre><p>解析<list>子元素的方法：</list></p>
<pre><code>//解析&lt;list&gt;集合子元素  
public List parseListElement(Element collectionEle, BeanDefinition bd) {}
 //具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析  
protected void parseCollectionElements(
        NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String defaultElementType) {} 
</code></pre><p>经过对Spring Bean定义资源文件转换的Document对象中的元素解析，Spring IoC现在已经将XML形式定义的Bean定义资源文件转换为BeanDefinition，它是Bean定义资源文件中配置的POJO对象在Spring IoC容器中的映射，我们可以通过AbstractBeanDefinition为入口，对IoC容器进行索引、查询和操作。</p>
<p>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的初始化过程，接下来需要向容器注册Bean定义信息才能全部完成IoC容器的初始化过程</p>
<h5 id="IoC容器中的注册"><a href="#IoC容器中的注册" class="headerlink" title="IoC容器中的注册"></a>IoC容器中的注册</h5><p>DefaultBeanDefinitionDocumentReader对Bean定义转换的Document对象解析的结果中最后调用processBeanDefinition()方法，其中就有调用BeanDefinitionReaderUtils的registerBeanDefinition方法向IoC容器注册解析的Bean，BeanDefinitionReaderUtils的注册的源码如下：</p>
<pre><code>//将解析的BeanDefinitionHold注册到容器中 
public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)  
throws BeanDefinitionStoreException {  
    //获取解析的BeanDefinition的名称
     String beanName = definitionHolder.getBeanName();  
    //向IoC容器注册BeanDefinition 
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());  
    //如果解析的BeanDefinition有别名，向容器为其注册别名  
     String[] aliases = definitionHolder.getAliases();  
    if (aliases != null) {  
        for (String aliase : aliases) {  
            registry.registerAlias(beanName, aliase);  
        }  
    }  
}
</code></pre><p>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory。</p>
<h5 id="注册解析后的BeanDefinition"><a href="#注册解析后的BeanDefinition" class="headerlink" title="注册解析后的BeanDefinition"></a>注册解析后的BeanDefinition</h5><p>DefaultListableBeanFactory中使用一个HashMap的集合对象存放IoC容器中注册解析的BeanDefinition，向IoC容器注册的主要源码如下：</p>
<pre><code>//存储注册的俄BeanDefinition  
private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();  
//向IoC容器注册解析的BeanDefiniton  
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)  
       throws BeanDefinitionStoreException {  
   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);  
   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);  
   //校验解析的BeanDefiniton  
   if (beanDefinition instanceof AbstractBeanDefinition) {  
       try {  
           ((AbstractBeanDefinition) beanDefinition).validate();  
       }  
       catch (BeanDefinitionValidationException ex) {  
           throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,  
                   &quot;Validation of bean definition failed&quot;, ex);  
       }  
   }  
   //注册的过程中需要线程同步，以保证数据的一致性  
   synchronized (this.beanDefinitionMap) {  
       Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);  
       //检查是否有同名的BeanDefinition已经在IoC容器中注册，如果已经注册，  
       //并且不允许覆盖已注册的Bean，则抛出注册失败异常  
       if (oldBeanDefinition != null) {  
           if (!this.allowBeanDefinitionOverriding) {  
               throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,  
                       &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &apos;&quot; + beanName +  
                       &quot;&apos;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);  
           }  
           else {//如果允许覆盖，则同名的Bean，后注册的覆盖先注册的  
               if (this.logger.isInfoEnabled()) {  
                   this.logger.info(&quot;Overriding bean definition for bean &apos;&quot; + beanName +  
                           &quot;&apos;: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);  
               }  
           }  
       }  
       //IoC容器中没有已经注册同名的Bean，按正常注册流程注册  
       else {  
           this.beanDefinitionNames.add(beanName);  
           this.frozenBeanDefinitionNames = null;  
       }  
       this.beanDefinitionMap.put(beanName, beanDefinition);  
       //重置所有已经注册过的BeanDefinition的缓存  
       resetBeanDefinition(beanName);  
   }  
}
</code></pre><p>至此，Bean定义资源文件中配置的Bean被解析并且注册到IoC容器中。现在IoC容器中已经存在了所有Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。因为IOC容器持有这些BeanDefinition信息，所以可以根据描述进行bean的注入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在通过上面的代码，总结一下IOC容器初始化的基本步骤：</p>
<ul>
<li><p>初始化的入口在容器实现中的 refresh()调用来完成</p>
</li>
<li><p>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,</p>
<blockquote>
<p>其中的大致过程如下：</p>
<p>通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置;</p>
<p>如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的;</p>
<p>容器通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 (实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的)，从而得到 bean 的定义信息;</p>
<p>这些信息在 Spring 中使用 BeanDefinition 对象来表示( 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition  这些相关的方法 ) 他们都是为处理 BeanDefinitin 服务的， </p>
<p>容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。</p>
<p>注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.</p>
</blockquote>
</li>
</ul>
<hr>
<blockquote>
<p>在使用 Spring IOC 容器的时候我们还需要区别两个概念:Beanfactory 和 Factory bean，</p>
<ul>
<li>BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext， XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。 </li>
<li>FactoryBean 只是一个可以在 IOC而容器中被管理的一个 bean,是对各种处理过程和资源使用的抽象,Factory bean 在需要时产生另一个对象，而不返回 FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，返回其生成的对象。</li>
</ul>
</blockquote>

      
    </div>

	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/spring/" rel="tag"># spring</a>
          
            <a href="/tags/ioc/" rel="tag"># ioc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/highly-concurrent.html" rel="next" title="高并发系统优化">
                <i class="fa fa-chevron-left"></i> 高并发系统优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/spring-aop.html" rel="prev" title="spring AOP解析">
                spring AOP解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="gamesdoa" />
          <p class="site-author-name" itemprop="name">gamesdoa</p>
           
              <p class="site-description motion-element" itemprop="description">那些爬过走过跑过飞过的坎坷道路和酸甜苦辣--是我逝去的青春</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是IOC"><span class="nav-number">1.</span> <span class="nav-text">什么是IOC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-IOC体系结构"><span class="nav-number">2.</span> <span class="nav-text">Spring IOC体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory"><span class="nav-number">2.1.</span> <span class="nav-text">BeanFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanDefinition"><span class="nav-number">2.2.</span> <span class="nav-text">BeanDefinition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-IOC-流程"><span class="nav-number">3.</span> <span class="nav-text">spring IOC 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整体看继承实现关系"><span class="nav-number">3.1.</span> <span class="nav-text">整体看继承实现关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ClasspathXmlApplicationContext的IOC容器流程"><span class="nav-number">3.2.</span> <span class="nav-text">ClasspathXmlApplicationContext的IOC容器流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">3.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassPathXmlApplicationContext完整源码"><span class="nav-number">3.2.2.</span> <span class="nav-text">ClassPathXmlApplicationContext完整源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析初始化"><span class="nav-number">3.2.3.</span> <span class="nav-text">解析初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设置Bean资源加载器"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">设置Bean资源加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定位bean定义的资源文件"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">定位bean定义的资源文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refresh方法"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">refresh方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#refresh源码"><span class="nav-number">3.2.3.3.1.</span> <span class="nav-text">refresh源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#refreshBeanFactory源码"><span class="nav-number">3.2.3.3.2.</span> <span class="nav-text">refreshBeanFactory源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#loadBeanDefinitions源码"><span class="nav-number">3.2.3.3.3.</span> <span class="nav-text">loadBeanDefinitions源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读取Bean定义资源"><span class="nav-number">3.2.3.3.4.</span> <span class="nav-text">读取Bean定义资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取要读入的资源"><span class="nav-number">3.2.3.3.5.</span> <span class="nav-text">获取要读入的资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加载Bean定义资源"><span class="nav-number">3.2.3.3.6.</span> <span class="nav-text">加载Bean定义资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#换为Document对象"><span class="nav-number">3.2.3.3.7.</span> <span class="nav-text">换为Document对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解析Bean定义资源"><span class="nav-number">3.2.3.3.8.</span> <span class="nav-text">解析Bean定义资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对Document解析"><span class="nav-number">3.2.3.3.9.</span> <span class="nav-text">对Document解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanDefinitionParserDelegate"><span class="nav-number">3.2.3.3.10.</span> <span class="nav-text">BeanDefinitionParserDelegate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IoC容器中的注册"><span class="nav-number">3.2.3.3.11.</span> <span class="nav-text">IoC容器中的注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注册解析后的BeanDefinition"><span class="nav-number">3.2.3.3.12.</span> <span class="nav-text">注册解析后的BeanDefinition</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gamesdoa</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "370e40e6557149eba0995419f9916493",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("bJ6SDp0eeVUg2nHJ0Xb6p01w-gzGzoHsz", "wre8x8t7Hal4YpTtUgP9kGI4");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
