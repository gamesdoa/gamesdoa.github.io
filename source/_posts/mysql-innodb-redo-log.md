---
title: mysql InnoDB redo log 分析
date: 2017-05-05
tags: 
	- mysql
	- redo log
categories:
    - mysql
keywords: innodb,redo,log,redo log,LSN,检查点
description: mysql的InnoDB存储引擎通过redo log实现事务的持久化，那么redo log的实现原理是怎么样的呢？LSN的作用是什么，为什么LSN会贯穿整个redo log的实现中？检查点又是来做什么的？redo log的架构是怎么样的？为什么说redo log不需要使用doublewrite技术？为了提供数据库性能，redo log做了哪些优化？且听小生慢慢道来。
---

redo log简介
---

**重做日志（redo log）** 用来实现事物的持久化，即事务ACID中的D。redo log由两部分组成：


- 内存中的redo log buffer 易丢失
- 外存中的redo log file 持久的


InnoDB通过force log at commit机制实现事务的持久化，即当事务commit时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待完成后事务的commit操作才算完成。

redo log基本上是**顺序写**，并且在数据库运行期间不需要对redo log的文件进行读取操作。

为了确保每次日志都写入到redo log file，在每次将redo log buffer写入到redo log file后，InnoDB存储引擎都需要调用一次fsync操作，因为redo log先写入到文件系统缓存，为了确保redo log写入到磁盘，必须进行一次fsync操作，这里也一般是数据库系统的瓶颈。事务TPS取决于磁盘性能。


>参数innodb_flush_log_at_trx_commit可以设置磁盘刷新策略

>- 0：事务不强制写入redo log，写入操作仅在master thread中进行完成，而master thread中每一秒进行一次redo log的fsync，因此宕机时有可能丢失最后一秒的数据。
>- 1：InnoDB默认值，每次事务提交都调用fsync操作，保证事务的完整性。
>- 2：事务提交时，redo log写入redo log file，仅写入到文件系统的缓存中，不进行fsync操作。数据库宕机，操作系统不宕机数据不丢失，操作系统宕机会丢失未从文件系统缓存刷新到redo log file那部分的数据。


	对于插入50W数据的情况下设置不同值对于插入的速度影响如下
    innodb_flush_log_at_trx_commit         执行所用时间
					0						13.90s
					1						1m53.11s
					2						23.37s




物理逻辑日志
----
不同的数据库系统针对重做日志有不同的实现方式，一般会有以下几种类型

- 物理日志
- 逻辑日志
- 物理逻辑日志

**物理日志(physical logging)**：又称old value-new value logging，该日志是幂等的，保存的是页中发生变化的字节。**问题**是日志产生的量相对较大，例如对页整理的话，日志大小可能为页的大小

**逻辑日志**：记录的是对于表的操作，因此日志量很小(基本上是只记录操作语句)。**问题**是恢复时可能无法保证数据的一致性(宕机时可能使数据处于未知状态)。

**物理逻辑日志**：设计思路是：physical-to-a-page，logical-within-a-page。也就是对于也是记录物理日志，对于页内的操作是记录逻辑日志，这能很好地结合物理日志和逻辑日志的优点。例如对于页整理，如果使用物理日志形式，日志量需要一个页大小，而使用物理逻辑日志形式，只需要记录页的编号以及日志的类型

LSN : log sequence number(日志序列号)
---

LSN特点是单调递增，代表每个重做日志的编号，这就意味着每一个日志都有一个LSN与之一一对应。
存在于多个对象中，表示的含义各不相同

- 操作日志
- 页
- 检查点

**操作日志**：LSN是事务写入操作日志的字节总量，LSN记录的是操作日志的增量，单位字节。例如当前LSN1000，事务T1产生100字节的操作日志，那么LSN变成1100，事务T2产生200字节的操作日志，那么当前LSN为1300。**InnoDB存储引擎**首先是将重做日志写入到一个缓存中，因此存在已经写入到重做日志缓冲和重做日志文件的两部分LSN信息。

**页**：页的头信息中FIL_PAGE_LSN存储的是页的LSN，表示该页最后刷新的LSN大小，由于操作日志记录的是每个页的日志，因此页中的LSN可以用来判断该页是否需要进行恢复操作。例如：页P1的LSN为1000，数据库启动时InnoDB检测到写入重做日志中该页的LSN为1300并且事务已经提交，那么数据库需要进行恢复操作，需要将重做日志应用到P1中。如果重做日志的LSN小于P1页的LSN，则不需要进行重做操作。

**检查点**：表示页已经刷新到磁盘的LSN位置，当数据库重启时，仅需要从检查点开始进行恢复操作。若检查点的LSN与操作日志的LSN相同，表示所有页都已经刷新到磁盘，不需要进行恢复操作。这样的好处是减少数据库重启时间。

	mysql> SHOW INNODB STATUS\G;
	......
	---
	LOG
	---
	Log sequence number 0 11347131
	Log flushed up to   0 11338553
	Log checkpoint at   0 11056147
	......

>Log sequence number表示重做日志缓冲中已经写入的LSN值，Log flushed up to表示已经刷新到重做日志文件的LSN值，由于重做日志缓冲在master thread中会每秒定期地进行刷新到磁盘的操作，因此两者之间的差距很小。

>Log checkpoint at表示最新一次页刷新到磁盘时的LSN。该值与前两个值差距可能比较大。具体原因见下一部分的检查点相关


检查点
---
InnoDB存储引擎采用write ahead log(WAL)策略实现事务的持久性，即当事务提交时，首先将重做日志写入到文件，实际数据页刷新到磁盘的操作由检查点（checkpoint）负责。也就是说事务的日志在事务提交时确定写入到外存，但是缓冲池(buffer pool)中的页并没有刷新到磁盘，**这是因为事务提交时仅仅是把事务操作所涉及页的重做日志都写入到磁盘(顺序写)**。页的刷新时异步的，也就是检查点技术。

**检查点的操作**就是将缓冲池中的页刷新到磁盘,最终达到外存和内存中的页的数据一致。

**检查点的作用**缩短当数据库发生宕机时数据库恢复所需要的时间。

**宕机后的恢复**：检查点的值是根据LSN记录的，当检查点的值是1000，重做日志刷新到的位置为1300，那么1000之后的重做日志需要回放(replay)。也就是说因为有检查点操作回放重做日志只需要进行1000到1300之间的数据，如果没有进行过checkpoint那么需要回放所有的重做日志。

InnoDB中存在两种检查点：

- sharp checkpoint
- fuzzy checkpoint

> sharp checkpoint将缓冲池中修改的页(脏页)，全部刷新到磁盘。**优点**是可以大大缩短宕机恢复所需要的时间。**缺点**是在进行sharp checkpoint时不能进行其他的DML操作，生产环境不可接受。
> 
> fuzzy checkpoint将缓冲池中修改的页(脏页)，慢慢的刷新回磁盘。**优点**大大提高数据库的可用性，刷新时也可以进行DML操作。**注意项**脏页需要根据第一次被修改时的LSN进行排序，然后将最老的页先刷回到磁盘，也就使得页的刷新和日志的LSN顺序是一样的，从而保证恢复操作的准确性。

归档日志与恢复
---
- **归档日志**：InnoDB存储引擎中，重做日志文件的大小是固定的，如果写入的日志大于重做日志文件的固定大小，就需要循环使用重做日志文件，这种方式称为round robin(轮循)。也就意味着之前写入的日志可能被新的日志覆盖，为了保留之前的重做日志，InnoDB存储引擎设计了归档日志，与重做日志文件的内容是完全相同的。

- **恢复**：InnoDB存储引擎在启动时不管上次数据库是否正常关闭，都会尝试进行恢复操作。重做日志记录的是物理逻辑日志因此恢复起来速度很快，并且InnoDB存储引擎也对恢复进行了优化，采用顺序读取并行应用重做日志方式加速恢复。而且因为有checkpoint技术存在，恢复过程中仅需要恢复checkpoint记录的LSN之后的日志部分，再次加速了恢复过程。

重做日志物理架构
---
InnoDB存储引擎中的重做日志由以下几个部分组成

- 重做日志缓存(redo log buffer)
- 重做日志组(redo log group)
- 每个重做日志组包含多个重做日志文件(redo log file)
- 归档重做日志文件


![重做日志存储结构](https://github.com/gamesdoa/img0/raw/master/mysql/redo-log/redo%E7%89%A9%E7%90%86%E6%9E%B6%E6%9E%84.jpg)

其中重做日志组是完全相同的镜像关系，目的是提高数据库的可用性，当一组中的介质损坏时。InnoDB存储引擎依然能够提供服务，虽然mysql的InnoDB这样设计了重做日志组，但是从源码层面看，其实并不能把重做日志组设置为1以外的值，否则会抛出InnoDB： or a wrong number of mirrored log group导致数据库不能启动，这是因为考虑到InnoDB存储引擎的性能，并且数据本身可以通过RAID保证数据的可靠性造成的。

重做日志文件是round robin(轮循)的多个同样大小的文件，默认前缀ib_logfile，总文件大小不能超过4GB。

归档日志是针对重做日志的备份归档，默认前缀ib_arch_log_，并且归档只对重做日志组1中的文件进行归档。

重做日志块
---
在InnoDB存储引擎中重做日志都是以512字节进行存储的，即重做日志缓存，重做日志文件，归档重做日志都是以块的方式保存的。但是如果一个页中产生的重做日志数量大于512字节，那么就需要分割为多个重做日志块进行存储

**重做日志块的大小跟磁盘扇区大小一样**，都是512字节，因此重做日志的写入可以保证原子性，不需要doublewrite技术。

**从数据结构看**：重做日志块除了日志本身，还有日志块头和日志块尾两部分，日志头一共占12个字节，日志尾占用8个字节，因此每个日志块其实只能存储492字节的日志。

重做日志组与重做日志文件
---
InnoDB存储引擎的重做日志组在源码层面被限定成了一个，因此这里不过多的关注。

重做日志组由多个重做日志文件组成，而重做日志文件存储的是log buffer中保存的log block，因此也是存储的512字节大小的数据块。
在InnoDB存储引擎运行期间log buffer根据一定的规则将内存中的log block刷新到磁盘，这里包括：

- 事务提交时
- 写入检查点值时
- 当log buffer中有已使用空间超过某个阈值时

重做日志组中每个文件的前2KB的部分不存储log block信息，但是在且仅在重做日志组的第一个重做日志文件存储固定的内容，其余文件留空。

> 
	redo log file前2KB部分内容
			存储内容       大小(字节)
		log file header      512
		checkpoint1          512
		空                   512
		checkpoint2          512

当写入log block的时候，需要更新前2KB部分的信息，这就导致了log block的写入不是完全顺序的。

从上面结构中看出**检查点(checkpoint)**有两个字，这个设计是为了避免介质失败，提高可用性。这两个checkpoint block是交替更新，因此在恢复数据是，只需要更新LSN大于较大的checkpoint的值的重做日志就可以。
![InnoDB中的各种LSN](https://github.com/gamesdoa/img0/raw/master/mysql/redo-log/InnoDB%E4%B8%AD%E5%90%84%E7%A7%8DLSN.jpg)

> 除了重做日志缓冲在事务提交时需要刷新到磁盘外，其他的LSN信息都是异步的刷新到持久存储上。

组提交
---
我们知道事务提交时为了确保重做日志持久化到磁盘上，需要调用一次fsync操作，而fsync性能又比较低，那么为了提高数据库性能，所以提出了组提交的概念。

当重做日志缓冲刷新到重做日志文件时，InnoDB存储引擎会对最后一个操作日志块进行复制，为什么要这样实现？原因是：重做日志文件的写入都是由缓存写的，fsync操作在log->mutex之后，这样使其他事物可以继续将重做日志写入到redo log buffer中，实现组提交功能。

重做日志恢复
---
如何判断数据库是否需要恢复：数据库关闭时最后刷新页的LSN和重做日志中保存的检查点比较，如果相等，则不需要恢复，否则需要恢复，查找重做日志文件中的两个检查点的较大值，恢复区间为最后刷新页的LSN到重做日志文件最大检查点之间的数据。
恢复方式是：每次读取64KB（64K/512=128个重做日志块），进行分析，判断重做日志块中的日志是否包含上一个日志的内容(一个日志存在于多个日志块中)，之后根据日志对于的（space，offset）的哈希值插入到哈希表，最后根据哈希表中的日志进行页的恢复。