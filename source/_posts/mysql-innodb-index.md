---
title: mysql InnoDB 索引分析及优化
date: 2017-07-01
tags: 
	- mysql
	- InnoDB
	- B+Tree
categories:
    - mysql
keywords: innodb,B+Tree,索引优化,最左前缀,聚族索引
description: mysql的InnoDB索引是如何实现的？为什么InnoDB的索引要遵循最左前缀的规则？什么是聚族索引，什么又是辅助索引或者非聚族索引，他们之间的关系是怎么样的？如何根据InnoDB的实现来优化我们自己的sql语句？且听小生慢慢道来。
---

B+Tree索引
---
B+Tree的数据结构这里就不详细表述了，如果你还不了解什么是B+Tree，请参考这里[https://zh.wikipedia.org/wiki/B%2B%E6%A0%91](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91 "B+树")，如果你不想花费时间研究B+Tree，在这里也附上一张个人理解的InnoDB实现的B+Tree图，并会稍作说明。

![B+Tree个人理解图](https://github.com/gamesdoa/img0/raw/master/mysql/innodb-index/B%2BTree.jpg)

- B+Tree是一个多路查找树，扁平结构。
- 非叶子节点只存储指向下层节点的指针。
- 兄弟非叶子节点之间不存在指向指针。
- **数据只存储在叶子节点上。**
- 每个叶子节点都有一个指向下个叶子节点的指针(持有兄弟叶子节点的指针)。
- 每个节点都是一个16k大小的页
- 数据插入时需要考虑负载因子和页分裂(页数据半分或者直接新页)
- 数据删除时需要考虑负载因子和页合并
- 非叶子节点指向叶子节点的指针，只能指向该叶子节点的页，具体数据需要把页加载到内存中然后使用二分查找定位数据。
- 所有的值都是顺序存储的，叶子结点中
- 在查找的时候必须按照最左前缀原则并且不能跳列，不然无法使用索引。
- 在查询使用索引的时候如果遇到范围查询，范围查询的列右边的列将不会被使用到索引。

索引
---

#### 索引优点： ####

- 大大减少服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 将随机I/O变为顺序I/O

#### 索引缺点： ####

- 对于小表，索引会增加额外的功能，全表扫描反而更快
- 对于特大表，建立索引的代价太高，不适用，可以使用分区表。

#### 如何建立高性能索引？ ####

- 索引列的干净，独立
	> 索引列不能是表达式的一部分，也不能是函数的参数。使用时也只能是干净的列。
- 缩小索引列的数据
	> 对于索引列数据量特别大的情况，如果全量存储会使索引变得大而且也会慢：大是因为数据量大而产生的数据在索引页中占用大量空间，对于固定页大下的InnoDB存储引用，单个数据量大造成每个页上存储的数据的数量变少，而且还会造成索引树的高度增加，对于相同数量级的数据，I/O次数会更多。
	> 
	> 前缀索引是个不错的选择，取数据开始的一部分进行索引，要考虑索引的选择性问题，选择性越高，索引效率越好，但是也可能占用的空间越大。
	> 
	> 对于BLOB、TEXT、很长的VARCHAR都需要前缀索引
	> 
	> ADD KEY (col(num)) 创建前缀索引。
- 多列索引
	>mysql中单列索引是针对每个需要索引的列单独设置索引，但是这种设置索引的方式对于where单条件查询来说很方便，但是我们很多时候都是需要多个索引相交操作的，这时候多个单列索引最好的情况也就只能是索引合并，索引合并涉及计算并不会统计在查询成本中。
	>
	>所以一般情况下，我们不会针对单列创建索引，而是根据具体使用sql创建多列索引。
	>
	>**多列索引列顺序**：
	>> 1. 依赖于使用该索引的查询，并要符合最左前缀原则
	>> 2. 需要考虑如何更好的满足排序和分组的需要
	>
	>如果不需要考虑排序和分组时，将选择性最高的列放在索引最前面同时最好选择数据基数小的列在前面

- 聚族索引
	>InnoDB采用的是聚族索引方式，就是按照ID生成的B+Tree结构， 完整数据存储在该树的叶子节点。
	>对于非ID的索引生成的B+Tree结构，最终叶子节点存储的是指向聚族索引的key，也就是ID，因此为了顺序的写入减少随机IO，在设计表的时候尽量对于每一张表设计一个自增主键最为ID。
- 非聚族索引
	>针对除了主键ID产生的B+Tree之外的索引树，都是非聚族索引。该树的最终叶子节点存储的是聚族索引的ID，也就导致如果需要查询该行所有的记录的话，需要再回源聚族索引。同时在非聚族索引的列中默认会在最后添加ID，已达到索引的key唯一性。也就是说如果创建（列1，列2）的索引，那么最终的索引形式表现为（列1，列2，ID）这样的结构
- 覆盖索引
	> 对于非聚族索引，如果能在查询时select的列中所有的数据对存在于队列索引中，那么该查询在最终叶子节点中能找到所有的数据不需要再到聚族索引中去回源数据。这样就节省了回源的开销和IO。在EXPLAIN中可以展示为Using index
- 使用索引扫描来做排序
	> 扫描索引速度很快，只需要从一条索引记录移动到紧接着的下一条记录，但是如果索引不能覆盖查询所需的全部列，就不能不把扫描到的行回源聚族索引读取对应行记录，这个操作是一个随机I/O，速度将会很慢，所以如果能将一个索引即满足排序，又用于查找行，那么查询的速度无疑是最好的。当然只有当索引的列顺序和ORDER BY子句的顺序完全一致并且所有列的排序方向都一致时，才会使用到索引扫描排序。

	> 必须在排序子句中完全满足最左前缀，并且排序顺序一致，当然如果最左前缀的前面一项或者几项是常量的话可以不关注该项，但是该项必须出现在where子句中，这样也能满足最左前缀。
	

以上是一些自己的小看法，如果有不足之处，希望各位看客批评指正。