---
title: hotspot GC分析
date: 2017-06-20
tags: 
	- java
	- jvm
categories:
    - java
keywords: hotspot,GC算法,分代收集,CMS,G1,throughput
description: hotspot作为sun公司对于jvm的实现，采用了什么思路，这一思路下各个部分是怎么样实现垃圾回收的？又有哪些GC策略？每种gc策略之间有什么区别？我们的应用又该怎么样选择gc策略？每一种gc策略要怎么样进行调优，需要关注那些调优点？对于这些问题我们来一起说道说道。
---

为什么需要关注GC以及内存分配
--
> jvm内存的动态分配和内存回收技术已经相当成熟了，我们看起来不需要关注GC和内存分配也能很好地工作，那么我们为什么还要去了解GC和内存分配呢？

>其实答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当GC成为系统达到更高并发的瓶颈时，我们只有知道了它的工作原理，才能对其进行监控分析，才能找到问题解决问题。

**在进行hotspot虚拟机的算法实现分析之前，我们需要先了解一下下面这些概念。**

区分对象是死亡还是存活的算法
---

### 引用计算算法 ###
**引用计算(Reference Counting)**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1，当引用失效是计数器减1，任何时刻计数器为0时，说明对象不可能被使用。

这种算法实现简单，判断效率很高，但是会有循环引用问题，A引用B，B也引用了A，这样即使没有其他对象引用，也不会被垃圾回收。

### <span id = "ra">可达性分析算法</span> ###
**可达性分析(Reachability Analysis)**：通过一系列被称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链的时候，说明对象不可用。
这种算法的效率和存活对象大小有关，当大量存活对象存在时，效率比较低，但是不会有循环引用不问题。java内存回收一般就是使用这种算法实现的。

![可达性分析对象是否能被回收](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.jpg)

在java语言中，可作为GC Roots的对象包括以下几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象。
- 方法区中的静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

垃圾收集算法
---
### 标记-清除算法 ###
最基础的收集算法，分为标记和清除两个阶段，标记阶段采用可达性分析算法，清除阶段，直接清除可回收的对象。

![标记-清除算法](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.jpg)

不足：

- 效率问题：标记和清除两个过程的效率都不高。
- 空间问题：标记清除之后会产生大量不连续的内存碎片，可能导致分配较大对象时，虽然有足够空间，但是却不能分配，会导致提前出发另外一种垃圾收集动作(后面讲CMS收集器的时候，并发失效的情况就有一种情况是因为这个原因造成的)
### 复制算法 ###
为了解决效率问题，于是出现了复制算法(Copying)，它的实现是把内存按照容量划分成大小相等的两块，每次只使用其中一块，当这一块内存用完，就将还存活的对象复制到另一块上面，然后再把已使用过的内存开间一次清理掉。这样就可以每次对整个半区进行内存回收，内存分配时也就不会出现碎片问题，而且只需要移动堆顶的指针，按顺序分配内存即可，实现简单，运行效率高。

![copying算法示意图](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/copying.jpg)

不足：
> 内存分为两部分，可使用一下子就只剩下原有内存的一半，代价优点太高了，但是根据新生对象朝生夕死的特点，不需要分成对等的两部分，可以按照8：1：1分成3部分(具体实现详见hotspot新生代内存管理)

> 存活对象较多的时候复制代价比较大，效率也会比较低。

### 标记-整理算法 ###
针对标记-清除算法的空间碎片问题，提出了改方案，就是标记阶段和标记-清除一样，但是之后的阶段为整理，就是把存活对象都向一端移动，然后直接清理掉边界以外的内存：

![标记-整理算法示意图](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/mark-compact.jpg)

### 分代收集算法 ###
根据对象存活的特点把内存划分成几块，比如划分为新生代和老年代，这样就能根据不同年代的特点采用不用的收集算法。

- 在新生代，对象一般都是朝生夕死，存活对象相对较少，这种就适用复制算法
- 在老年代，对象存活比较久，存活对象数量比较多，很显然不适合复制算法，只能使用标记-清除或者标记-整理算法。

**了解了以上的概念之后，我们再来看一下hotspot算法的实现**

Hotspot算法实现
---

### 枚举根节点 ###
使用到我们之前说到的[可达性分析算法](#ra),其中可作为GC Roots的节点主要是全局性的引用与执行上下文，在方法区特别大的时候如果逐个检查必然会消耗很多时间，而且在可达性分析时还要求分析工作必须确保**分析过程中的一致性**，也就造就了这一阶段必须停顿所有执行线程也就是俗称的 **Stop The World(STW)**。那么即要求STW又会消耗很多时间，而对于程序执行而言，同样希望停顿时间越短越好，那么有什么好的解决办法呢？

对于Hotspot来说，Hotspot使用一组称为OopMap的数据结构来处理，在类加载完成的时候，Hotspot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编辑过程中也会在特定的位置记录下栈和寄存器中那些位置是引用，这样GC在扫描的时候就可以直接通过OopMap得知这些信息，不需要一个不漏的检查所有执行上下文和全局的引用位置，已达到高效的目的，缩短STW时间。

### 安全点 ###
在OopMap的协助下，Hotspot可以快速准确的完成GC Roots枚举，但是因为Oopmap内容变化的指令非常多，不可能为每一条指令都生成对应的OopMap，只能在特定的位置上记录这些信息，这个特定位置称为安全点(Safepoint)
>也就是所程序并不是在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

怎么样才能在GC发生时让所有线程都跑到最近的安全点上再停顿下来呢？

Hotspot采用主动式中断思想，当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。**轮询标志的地方和安全点设置成重合的，**同时还是创建对象需要分配内存的地方。

### 安全区域 ###
当线程处于Sleep或者Blocked状态的时候，线程明显就是不能相应中断请求，跑到安全点去，而且JVM也不可能等待线程重新被分配CPU时间，所以就需要安全区域(Safe Region)来解决。

> 安全区域是指，在一段代码中引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的。

在线程执行到Saft Region的时候，首先标识自己已近进入到Safe Region，那么，当在这期间JVM发起GC时，就不管标识自己为Safe Region的线程。当线程要离开Safe Region时，它要检查系统是否已经完成类跟节点枚举或者整个GC过程，如果完成，那么线程继续，否则，它必须等待收到可以安全离开Safe Region信号为止。

Hotspot堆内存划分
---
Hotspot的堆内存首先是划分为新生代和老年的，两个大的概念

- 新生代：根据复制算法的特点，新生代又划分成3个部分，一个Eden区，两个Survivor区。使用规则是：内存分配在Eden区开始，当Eden区被耗尽时，发生GC，这时存活的对象进入一个Survivor区(S0)，下一次再发生GC时，存活对象由Eden区和S0区进入S1区，如此反复。默认的分配比例**Eden:S0:S1 = 8:1:1**
- 老年的：不再划分区域。当老年的内存不足以存放进入老年的内存是发生GC。

Hotspot中的GC收集器
---
### Serial收集器 ###
特点：

- 单线程收集
- 只会使用一个CPU或者一个收集线程完成垃圾收集工作。
- 必须暂停其他所有的工作线程，也就是Stop The World(STW)。
- 由虚拟机后台发起并自动完成，用户不可控的。
> 根据Serial收集器的特点不难看出，在很多大型应用的场景下，这个收集器是不可接受的，那么它能在哪里使用呢？
> 
> sun公司把它设置成Client模式下新生代的默认收集器，在单个CPU的环境下，效率最高。

### Throughput收集器 ###
#### <span id="tmgc">MinorGC</span> ####
Eden空间耗尽时，新创建的对象无法分配到内存时发生GC，这时的GC称为MinorGC。

![throughput minor GC](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/throughput-minor.jpg)

如上图所示：在发生一次MinorGC的时候，会把Eden区和当前正在使用的Survivor区内的存活对象复制到另外一个空余的Survivor区内，然后清空eden区和使用的Survivor区。如此反复操作，每次GC时都是使存活对象存储在另外一个没有使用的Survivor区中。

- 当存活对象太多，Survivor区无法存放的情况下，会有部分存活对象直接进入老年代。
- 当对象在Survivor区经过多次GC周期(到达晋升阈值时)还存活的，则进入老年代。
 > 可以通过-XX:InitialTenuringThreshold=N 设置晋升老年代的阈值(默认7)
 > 
 > 如希望跟踪每次minor GC后新的存活周期的阈值，可在启动参数上增加：-XX:+PrintTenuringDistribution，
 > 
 > 输出的信息中的：Desired survivor size 1086516 bytes, new threshold 7 (max 15)
 > 
 > new threshold 7即标识新的存活周期的阈值为7。

#### FullGC ####
当老年代空间耗尽，无法存放新进入老年代对象时，发生GC，这种GC称为FullGC，一般时间比较长。

![throughput full GC](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/throughput-full.jpg)

如上图所示，发生FullGC的时候会默认清理新生代以及老年代的内存，并压缩活跃对象在老年代中保持。

- 需要注意的是FullGC之后Eden和两个Survivor区，也就是整个新生代全部清空。
    
	```java	
	//GC日志如下：
	3007005.033: [Full GC [PSYoungGen: 8786K->0K(679936K)]		//新生代清空
	[ParOldGen: 690616K->71645K(699392K)]		// 老年代压缩
	699402K->71645K(1379328K)		// 总的堆内存变化
	[PSPermGen: 55092K->55092K(55296K)]		//永久代
	, 0.3721260 secs]		//耗时
	[Times: user=0.61 sys=0.00, real=0.38 secs]		// CPU时间 0.61秒 真实时间 0.38秒 2个CPU处理
	```

#### 永久代GC ####
多数的FullGC永久代对象都不会回收，但是如果永久代空间耗尽，JVM也会发起FullGC回收永久代的对象。

#### 调优 ####
针对Throughput收集器的调优，主要是对可承受最大停顿时间和应用在垃圾回收上花费时间为基准的。

- -XX:MaxGCPauseMillis = N   可承受的最大停顿时间
- -XX:GCTimeRatio = N        应用在垃圾回收上花费的时间，默认值99，也就是垃圾回收花费时间占应用时间的1%,计算公式(1/(1+GCTimeRatio))

> 在 -XMS  、  -Xmx  、  XX:MaxGCPauseMillis = N 、-XX:GCTimeRatio = N 这些值当中MaxGCPauseMillis优先级最高，如果设置了这个值，新生代和老年代会随之进行调整，直到满足对应的停顿时间。一旦这个目标达成，堆得总容量就开始逐渐增大直到运行时间的比率达到设定值，这两个目标都达成后，JVM会尝试缩减堆得大小，尽可能以最小堆大小来满足这两个目标

### CMS收集器 ###
CMS : Concurrent Mark Sweep ,一款基于"标记-清除"算法实现的收集器，以获取最短回收停顿时间为目标的收集器。主要会做下面三件事情：

1. 对新生代的对象进行回收(Stop The World) 所有应用线程会被暂停。
2. 启动一个或多个并发线程对老年代空间的垃圾进行回收。
3. 如果有必要，CMS会发起FullGC

#### 新生代GC ####
新生代GC和Throughput收集器的MinorGC基本一样，[可以看这里](#tmgc)

#### 并发老年代GC ####

![并发收集老年代](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/CMS-old.jpg)

**整个并发回收的过程是：**

1. 初始标记  ：  暂停所有应用程序线程 STW
2. 标记阶段  ：  应用程序线程持续运行，不会被中断 
3. 预清理    ： 与应用程序并行
4. 重新标记  ： 可中断预清理(比如发生新生代GC) STW
5. 清除     ：  并发运行(可以被新生代垃圾回收中断)
6. 并发重置

**<span id="cmsf">并发失效的情况</span>：**

- 新生代垃圾回收，同时老年代又没有足够空间容纳晋升的对象时。日志中会出现(**<font color=#FF0000>concurrent mode failure</font>**)

		1285.946: [GC 1285.946: [ParNew: 353920K->353920K(353920K), 0.8003983 secs]
		1286.747: [CMS1287.338: [CMS-con current-sweep: 7.902/9.624 secs] 
		[Times: user=96.62 sys=2.35, real=9.62 secs] 
		(concurrent mode failure): 
		2531317K->1161025K(2752512K), 24.8330303 secs] 
		2860005K->1161025K(3106432K), 
		[CMS Perm : 37117K->3 6905K(62368K)], 25.6341706 secs] 
		[Times: user=26.41 sys=0.05, real=25.63 secs]

- 老年代空间可以容纳晋升对象，但是由于空间碎片化导致失败时。日志中会出现(**<font color=#FF0000>promotion failed</font>**)

		35333.562 : [GC  35333.562 : 
		[ParNew (promotion failed): 1877376K->1877376K(1877376K),  15.7989680  secs] 
		35349.361 : [CMS: 2144171K->2129287K(2146304K),  10.4200280  secs] 
		3514052K->2129287K(4023680K), 
		[CMS Perm : 119979K->118652K(190132K)],  26.2193500  secs] 
		[Times: user= 30.35  sys= 5.19 , real= 26.22  secs]
 
都会退化为FullGC，单线程处理并且Stop The World

#### FullGC ####

![CMS的FullGC](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/cms-fullgc.jpg)

并发失败后的退化为FullGC的情况下，示意图如上。

#### 永久代(元空间)GC ####
永久代空间耗尽，需要回收时，会发生FullGC，日志一般如下：

	```java	
	//GC日志如下：
	3007005.033: [Full GC 3007005.033:
		[CMS: 8786K->5847K(679936K), 0.6421260 secs]	
		699402K->5847K(1379328K),		// 总的堆内存变化
	[CMS Perm : 55092K->43092K(55296K)],	//永久代
	, 0.6721260 secs]		//耗时
	```

CMS收集后永久代空间大小减小了，Java8中，元空间也是一样的情况。
> 默认情况：CMS收集器不会对永久代(元空间)进行收集，但是，它一旦被耗尽，就需要进行Full GC，所有没有被引用的类都会被回收。

#### 调优 ####

1. 针对并发模式失效的调优
	- 想办法增大老年代空间.
	> 增加更多的堆空间(个人推荐)
	> 
	> 移动部分新生代空间到老年代:个人不推荐这种方式，因为新生代变小会带来一系列问题
	> >如非必要的对象可能会更快晋升到老年代，使老年代对象占用空间增加过快。
	> 
	> >会使新生代GC频率过高，导致对并发GC的中断，反而使并发更容易失效
	- 尽早开启并发收集，更早的启动并发收集，完成垃圾收集的几率就更大。
	> -XX:CMSInitiatingOccupancyFraction=N : 设置当老年代内的对象占老年代内存的百分之多少的时候，开启并发收集，默认值70.
	>> 我应该怎么样设置CMSInitiatingOccupancyFraction？
	>> 在GC日志中查找并发模式失效第一次出现的位置([如何查找](#cmsf))，然后再反向查找最近的一个启动日志，日志中含有CMS-initial-mark,然后827596k/1379328K=60% ，也就是60%的时候开始的并发收集。建议可以减少10-20%。
	
				6457.548: [GC [1 CMS-initial-mark:827596k(1379328K)]
						66428k(2379328K), 0.0830120 secs]
						[Times: user=0.08 sys=0.00, real=0.08 secs]]
	
	> 
	> -XX:+UseCMSInitiatingOccupancyOnly ： 直接使用设定的CMSInitiatingOccupancyFraction的值，还是虚拟机用更加复杂的方式计算出来开启占比？设置成true，直接使用。默认是false，虚拟机计算。


	- 使用更多的后台回收线程
	>每个CMS后台线程都会100%的占用机器上的一个CPU，如果应用并发模式失效，并且又有额外的CPU周期可用，可以设置-XX:ConcGCThreads=N标志，增加后台线程数目。默认情况下:ConcGCThreads = (3 + ParallelGCThreads) / 4;
	>> 为什么每个CMS线程都独占一个CPU？
	>> 其实这个不难理解，如果不是独占CPU的话，和别的应用程序公用，会出现资源竞争，会导致CMS线程的lose its race (失速)。
2. 针对永久代的调优
	默认情况下CMS不会对永久代进行垃圾回收，但是我们可以设置成与老年代同样的方式进行回收。
	-	开启 -XX:+CMSPermGenSweepingEnabled ： 该值默认是关闭的，开启后会启动与老年代一样的处理方式，但是使用的CPU和触发标志都是跟老年代**独立**的
	-	-XX:CMSInitiatingPermOccupancyFraction=N  ： 设置占比达到多少时开启收集线程，默认是80(80%)
	-	-XX:+CMSClassUnloadingEnabled ： 开启释放不再被引用的类，默认只能释放少量的无效对象，类的元数据并不会被释放，只有开启之后才能释放类的元数据。
		>java8中CMSClassUnloadingEnabled值默认是开启的。

### G1(Garbage-First)收集器 ###
G1：Garbage-First，顾名思义，会先收集垃圾最多的分区(region)。分区既可以归属老年代，也可以归属新生代(在使用的时候谁申请就分配给谁)，默认分区2048个，同一个代的分区不需要保持连续。

- **新生代**：其实没有绝对的必要分区，因为新生代进行垃圾回收时整个新生代空间要么被回收要么被晋升(移动到Survivor或者老年代)。采用分区的原因是可以方便的调整代的大小。
- **老年代**：可以把大的区域拆分，这样每次都关注垃圾最多的区域，降低花费时间。

G1收集器的收集活动主要包含4种操作：

1.	新生代垃圾收集；
2.	后台收集，并发周期；
3.	混合式垃圾收集；
4.	必要时的FullGc。

#### G1分区的大小 ####

分区大小不是动态变化的，具体值在启动的时候依据堆得大小的最小值得出，分区大小的最小值是1MB。如果堆得最小值超过2GB：

分区大小 = 1 << log(初始堆的大小/2048) //使用基数为2取log的算法

分区大小是2的最小的N次幂，并使其结果接近2048个分区
>分区限制：最小值1MB，最大值32MB
>
>可以使用-XX:G1HeapRegionSize=N设置值，N应该是2的幂，否则会向下取整到最近的2的幂。

#### 新生代垃圾收集 ####
![G1的新生代回收示意图](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/g1-young.jpg)

注：每一个小方块代表一个G1分区，黑色分区代表数据，[E]代表Eden、[O]代表老年代、[S]代表Survivor。
> 虽然Eden以及Survivor是按照区块分配的，但是Eden和Survivor区的格式还是像之前的内存格式，大小也是固定的。不要以为还有空闲的分区就能无限申请内存分配给Eden区或者Survivor区。

- **空的区域不属于任何一个代，需要的时候G1收集器会强制指定这些空的分区用于任何需要的代。**

Eden空间耗尽会触发G1垃圾收集器进行新生代垃圾收集(示意图中6个Eden分区)，新生代收集之后不会立刻又Eden区分配，但是会至少有一个Survivor区。
这里同样存在如果Survivor区扣减被填满，无法容纳的对象也会直接晋升到老年代。

#### 并发G1垃圾收集周期 ####
![G1的并发收集示意图](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/g1-curr.jpg)

注：一些分区被标注了X，他们就是标记周期找到的包含最多垃圾的分区(优先清理垃圾最多的区)。

- 示意图中新生代发生变化：说明在并发周期内至少有一次新生代GC。 
- X标注的区域属于老年代，同时依然保持有数据。 
- 老年代(O和X),在标记周期结束后可能会变得更大，新生代有对象会晋升到老年代。

下面来看一下并发周期包含哪些阶段，每个阶段都有哪些需要注意的点：

- 初始-标记(initial-mark) ： 会暂停所有应用线，这里的实现是重用了新生代GC周期完成这部分工作，因此**会做一次新生代收集**工作。
- 扫描根分区(root region) ： 并发运行，但是**不能发送新生代收集**，如果有新生代收集必须等待扫描结束才能继续新生代收集，会造成新生代收集停顿耗时更长。
- 并发标记(concurrent mark) ： 完全在后台进行，开始和完成分别会刷出一行日志，[GC concurrent-mark-start] 和 [GC concurrent-mark-end,6.3345 sec] ,可以被新生代GC中断。
- 重新标记(remarking) ： 暂停所有应用。
- 清理 ： 暂停所有应用。
- 并发清理

通过上面几个步骤，垃圾的定位就完成了(会清理很少的垃圾，主要是定位垃圾最多的分区，也就是X区)。

#### 混合式垃圾回收(mixed GC) ####
混合式垃圾回收：不仅进行正常的新生代垃圾收集，同时也会回收部分后台扫描线程标记的分区。
![G1的混合GC示意图](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/g1-gc.jpg)

注：G1收集器已经清空了Eden空间，同时调整了Survivor空间，并且三个标记X的分区也被回收，活跃数据移动到另外一个分区(减低了磁盘碎片化问题)。

- 混合式垃圾回收周期会持续运行直到所有标记的分区都被回收，然后G1收集器恢复正常的新生代垃圾回收周期，并重新开启一轮并发周期，标记下一次哪些区域需要垃圾释放。

#### FullGC ####
G1垃圾收集器在什么时候回启动FullGC？

- 并发模式失败
	>老年代在标记周期完成之前就被填满，放弃标记周期
		
		234.34: [GC concurrent-mark-start]
		245.23: [Full GC 4095M->1395M(4096M),8.12322 secs]
				[Times: user=6.40 sys=0.00 real=8.12 secs]
		254.34: [GC concurrent-mark-abort]
	> 出现这种情况可以通过一下手段解决：
	> 
	> - 增加堆得大小
	> - 更早开启后台处理
	> - 增加后台处理的线程数
- 晋升失败
	> 完成标记阶段，开始启动混合垃圾回收，清理老年代的分区，但是老年代空间在垃圾回收释放出足够内存之前，内存被耗尽。
	> 
	> 日志中可以看到在混合GC之后立刻一次FullGC
- 疏散失败
	> 进行新生代垃圾收集时，Survivor区和老年代没有足够的空间容纳所有的幸存对象。

		345.33: [GC pause (young) (to-space overflow), 0.823456700 secs]
	>表明堆已经用尽或者碎片化。最简单的就是增加堆大小
- 巨型对象分配失败
	> 分配大于分区的对象的时候，需要在老年代找几个连续的空闲分区，如果找不到，就只能进行fullGC，所以尽量避免分配巨型对象。

#### 调优 ####
目标：避免发生并发模式失败或者疏散失败，减少收集过程中的停顿时间最小化。可调优选项

- 通过增加总的堆空间大小或者调整老年代、新生代之间的比例来增加老年代空间的大小(调整比例不推荐，频繁新生代GC，遇到扫描根区分还要等待).
- 增加后台线程数目(在有足够CPU资源的情况下).
- 以更高的频率进行G1的后台垃圾收集活动。
- 在混合式垃圾回收周期内完成更多的垃圾收集工作。

最简单的调优方案：设置-XX:MaxGCPauseMillis=N。默认值200ms
> 如果G1收集器发生STW的时长购过该值，G1收集器会尝试弥补：弥补的方法是尝试上面四种方式。
> 如果还是不能避免FullGC的情况下，可以按实际情况调整下面的值：
> 
> - 调整后台线程数-XX:ConcGCThreads=N。默认的计算公式 ConcGCThreads = (ParalleGCThreads + 2) /4 (跟CMS收集很像是吧是？)
> - 调整G1垃圾收集器运行的频率。-XX:InitiatingHeapOccupancyPercent=N,默认45(45%),和CMS不一样的是这里的基数是整个堆大小，而不是像CMS那样只有老年代的大小。
> - 调整G1收集器的混合式垃圾收集周期。-XX:G1MixedGCCountTarget=N,G1垃圾收集回收分区时的最大混合式GC的周期数。默认8，减少可以帮助解决晋升失败的问题，代价是停顿时间更长。

		----------------	--------华丽的分割线--------------------------
高级调优
---
### 晋升以及Survivor空间 ###

新生代划分为一个Eden空间和两个Survivor空间的原因，让更多的对象在新生代内有更多的机会被回收。

	Eden->S0 //第一次
	Eden + S0 -> S1 //第二次
	Eden + S1 -> S0 //第三次  
	Eden + S0 -> S1 //第四次
	Eden + S1 -> S0 //第五次  
	...
	//如此循环。

- 什么时候对象会进入老年代？
> - Survivor不足以保存该次新生代GC中存活下来的对象的时候。
>	>-XX:InitialSurvivorRatio=N,调整Survivor空间的值。 survivor_space_size = new_size / (initial_survivor_ratio + 2)默认initial_survivor_ratio=8，所以每一个Survivor占比10%。
>	
>	>可以设置Survivor为某一个固定值：-XX:SurvivorRatio=N。同时需要关闭自动调整，-XX:-UseAdaptiveSizePolicy。
>	
> - 在Survivor经历了多个GC周期达到晋升阈值的时候。 
>	>-XX:InitialTenuringThreshold=N,设置晋升阈值(Throughput和G1默认:7，CMS默认是:6)
>	
>	>-XX:MaxTenuringThreshold=N，最大晋升阈值(Throughput和G1默认:15，CMS默认是:6)
>	>
>	>注：修改这个值要考虑一直不晋升造成的直接进入老年代问题，或者一直直接晋升进入老年代问题。

结：
如果Survivor过小，对象会直接晋升到老年代，从而触发更多的老年代GC，增加堆(至少增加新生代)的大小是最好的解决办法

### 分配大对象 ###
#### TLAB ####
TLAB：Thread Local Allocation Buffer 线程本地分配缓冲区
Eden区中对象分配速度更快的原因就是因为每个线程都有一个固定的TLAB用于分配对象，这样就不需要在线程间同步。
TLAB的大小由三个因素决定

- 应用程序的线程数
- Eden空间的大小
- 线程的分配率

哪些程序会受益于TLAB？

- 需要分配大量巨型对象的应用程序
- 相对于Eden空间的大小而言，应用程序线程数量过多的应用
>TLAB默认是开启的，-XX:-UseTLAB可以关闭，不够考虑到TLAB带来的性能提升，最好还是不要关闭了。

因为TLAB的大小基于线程的分配率，所以不太可能准确预测应用程序的TLAB的大小，但是可以监控TLAB的分配情况，如果有大量对象分配发生在TLAB之外，可以减小分配对象的大小，或者调整TLAB的参数。
>JFR可以监控TLAB的分配情况。

>-XX:PrintTLAB标志可以在新生代GC的日志中找到相应的TLAB信息

#### 调整TLAB ####
1. 增大Eden空间TLAB的值会自动增大
2. -XX:TLABSize=N可以显式的设置TLAB的大小，为了避免每次GC的时候都调整TLAB的大小，-XX:-ResizeTLAB关闭重设大小。

#### 巨型对象 ####
对于TLAB空间无法分配的对象，JVM会尽量尝试在Eden空间中进行分配，如果Eden空间无法容纳该对象，就只能在老年代中分配空间。G1收集器，超过分区的话也只能在老年代分配空间。


很low的调优线路图
--

![GC调优线路图](https://github.com/gamesdoa/img0/raw/master/java/hotspot-gc/gc.jpg)

